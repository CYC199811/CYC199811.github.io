<!DOCTYPE HTML>
<html lang="zh-CN">



<head>
    <meta charset="utf-8">
    <meta name="keywords" content="程玉春的博客">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>程玉春的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 7.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="程玉春的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">程玉春的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Medias</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/playlist/8249069662">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Musics</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">程玉春的博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Medias
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>

                  <a target="_blank" rel="noopener" href="https://y.qq.com/n/ryqq/playlist/8249069662 " style="margin-left:75px">
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>Musics</span>
                  </a>
                </li>
              
            </ul>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/CYC199811/CYC199811.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/CYC199811/CYC199811.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-05-18
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.9k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1-redis缓存原理，为什么快？"><a href="#1-redis缓存原理，为什么快？" class="headerlink" title="1.redis缓存原理，为什么快？"></a>1.redis缓存原理，为什么快？</h1><h2 id="主要有以下几个原因："><a href="#主要有以下几个原因：" class="headerlink" title="主要有以下几个原因："></a>主要有以下几个原因：</h2><ol>
<li><h2 id="内存存储：Redis将数据存储在内存中而不是磁盘上，内存的读写速度比磁盘快得多。"><a href="#内存存储：Redis将数据存储在内存中而不是磁盘上，内存的读写速度比磁盘快得多。" class="headerlink" title="内存存储：Redis将数据存储在内存中而不是磁盘上，内存的读写速度比磁盘快得多。"></a><em>内存存储：Redis将数据存储在内存中而不是磁盘上，内存的读写速度比磁盘快得多。</em></h2></li>
<li><h2 id="非关系型：作为一个键值存储系统，Redis不需要像关系型数据库那样进行复杂的连接操作，这减少了时间复杂度。"><a href="#非关系型：作为一个键值存储系统，Redis不需要像关系型数据库那样进行复杂的连接操作，这减少了时间复杂度。" class="headerlink" title="非关系型：作为一个键值存储系统，Redis不需要像关系型数据库那样进行复杂的连接操作，这减少了时间复杂度。"></a><em>非关系型：作为一个键值存储系统，Redis不需要像关系型数据库那样进行复杂的连接操作，这减少了时间复杂度。</em></h2></li>
<li><h2 id="单线程模型：Redis使用单线程模型处理命令，避免了多线程的上下文切换和竞态条件，让每个操作都极为快速且安全。"><a href="#单线程模型：Redis使用单线程模型处理命令，避免了多线程的上下文切换和竞态条件，让每个操作都极为快速且安全。" class="headerlink" title="单线程模型：Redis使用单线程模型处理命令，避免了多线程的上下文切换和竞态条件，让每个操作都极为快速且安全。"></a><em>单线程模型：Redis使用单线程模型处理命令，避免了多线程的上下文切换和竞态条件，让每个操作都极为快速且安全。</em></h2></li>
<li><h2 id="高效的数据结构：Redis支持多种类型的数据结构如字符串、列表、集合、有序集合等，并且对它们进行了优化，使得操作它们非常快速。"><a href="#高效的数据结构：Redis支持多种类型的数据结构如字符串、列表、集合、有序集合等，并且对它们进行了优化，使得操作它们非常快速。" class="headerlink" title="高效的数据结构：Redis支持多种类型的数据结构如字符串、列表、集合、有序集合等，并且对它们进行了优化，使得操作它们非常快速。"></a><em>高效的数据结构：Redis支持多种类型的数据结构如字符串、列表、集合、有序集合等，并且对它们进行了优化，使得操作它们非常快速。</em></h2></li>
<li><h2 id="持久化选项：即使是以内存为主的存储系统，Redis也提供了RDB和AOF两种数据持久化方法，可以根据需要选择适合的持久化策略。"><a href="#持久化选项：即使是以内存为主的存储系统，Redis也提供了RDB和AOF两种数据持久化方法，可以根据需要选择适合的持久化策略。" class="headerlink" title="持久化选项：即使是以内存为主的存储系统，Redis也提供了RDB和AOF两种数据持久化方法，可以根据需要选择适合的持久化策略。"></a><em>持久化选项：即使是以内存为主的存储系统，Redis也提供了RDB和AOF两种数据持久化方法，可以根据需要选择适合的持久化策略。</em></h2></li>
<li><h2 id="内建的复制特性：Redis支持主从同步复制，用于数据备份、读写分离和提升系统的扩展性和可用性。"><a href="#内建的复制特性：Redis支持主从同步复制，用于数据备份、读写分离和提升系统的扩展性和可用性。" class="headerlink" title="内建的复制特性：Redis支持主从同步复制，用于数据备份、读写分离和提升系统的扩展性和可用性。"></a><em>内建的复制特性：Redis支持主从同步复制，用于数据备份、读写分离和提升系统的扩展性和可用性。</em></h2></li>
</ol>
<h2 id="string：字符串类型，可以存储普通字符串、JSON字符串，也可以存储对象系列化之后的字符串"><a href="#string：字符串类型，可以存储普通字符串、JSON字符串，也可以存储对象系列化之后的字符串" class="headerlink" title="string：字符串类型，可以存储普通字符串、JSON字符串，也可以存储对象系列化之后的字符串"></a><em>string：字符串类型，可以存储普通字符串、JSON字符串，也可以存储对象系列化之后的字符串</em></h2><h2 id="hash：哈希类型，类似于Java中的HashMap，比较适合存储对象"><a href="#hash：哈希类型，类似于Java中的HashMap，比较适合存储对象" class="headerlink" title="hash：哈希类型，类似于Java中的HashMap，比较适合存储对象"></a><em>hash：哈希类型，类似于Java中的HashMap，比较适合存储对象</em></h2><h2 id="list：列表类型，底层是一个顺序链表，可以从两端添加或移除元素，元素是有序的，可重复的"><a href="#list：列表类型，底层是一个顺序链表，可以从两端添加或移除元素，元素是有序的，可重复的" class="headerlink" title="list：列表类型，底层是一个顺序链表，可以从两端添加或移除元素，元素是有序的，可重复的"></a><em>list：列表类型，底层是一个顺序链表，可以从两端添加或移除元素，元素是有序的，可重复的</em></h2><h2 id="set：无序集合，没有重复元素"><a href="#set：无序集合，没有重复元素" class="headerlink" title="set：无序集合，没有重复元素"></a><em>set：无序集合，没有重复元素</em></h2><h2 id="zset：有序集合，没有重复元素，且集合中每个元素关联一个分数，可以根据分数进行排序"><a href="#zset：有序集合，没有重复元素，且集合中每个元素关联一个分数，可以根据分数进行排序" class="headerlink" title="zset：有序集合，没有重复元素，且集合中每个元素关联一个分数，可以根据分数进行排序"></a><em>zset：有序集合，没有重复元素，且集合中每个元素关联一个分数，可以根据分数进行排序</em></h2><h1 id="2-redis缓存淘汰机制是怎么样的？"><a href="#2-redis缓存淘汰机制是怎么样的？" class="headerlink" title="2.redis缓存淘汰机制是怎么样的？"></a>2.redis缓存淘汰机制是怎么样的？</h1><p>Redis 缓存淘汰机制（Cache Eviction Policy）用于管理内存使用，当 Redis 实例达到配置的最大内存限制时，Redis 会根据指定的策略淘汰（移除）一些键值对，以释放内存空间。以下是 Redis 提供的几种缓存淘汰策略及其工作原理：</p>
<h3 id="1-noeviction"><a href="#1-noeviction" class="headerlink" title="1. noeviction"></a>1. noeviction</h3><ul>
<li><h3 id="描述：当内存限制达到时，不会再进行任何操作。新的写操作将会报错（返回错误信息）。"><a href="#描述：当内存限制达到时，不会再进行任何操作。新的写操作将会报错（返回错误信息）。" class="headerlink" title="描述：当内存限制达到时，不会再进行任何操作。新的写操作将会报错（返回错误信息）。"></a><strong>描述</strong>：当内存限制达到时，不会再进行任何操作。新的写操作将会报错（返回错误信息）。</h3></li>
<li><strong>适用场景</strong>：适合不希望任何数据被自动删除的场景，例如需要严格控制数据集大小的情况下。</li>
</ul>
<h3 id="2-allkeys-lru"><a href="#2-allkeys-lru" class="headerlink" title="2. allkeys-lru"></a>2. allkeys-lru</h3><ul>
<li><h3 id="描述：在所有键中，优先移除最少使用（最近最少使用，Least-Recently-Used）的键。"><a href="#描述：在所有键中，优先移除最少使用（最近最少使用，Least-Recently-Used）的键。" class="headerlink" title="描述：在所有键中，优先移除最少使用（最近最少使用，Least Recently Used）的键。"></a><strong>描述</strong>：在所有键中，优先移除最少使用（最近最少使用，Least Recently Used）的键。</h3></li>
<li><strong>适用场景</strong>：适用于希望将最常用数据保存在缓存中的场景。</li>
</ul>
<h3 id="3-volatile-lru"><a href="#3-volatile-lru" class="headerlink" title="3. volatile-lru"></a>3. volatile-lru</h3><ul>
<li><h3 id="描述：在设置了过期时间的键中，优先移除最少使用的键。"><a href="#描述：在设置了过期时间的键中，优先移除最少使用的键。" class="headerlink" title="描述：在设置了过期时间的键中，优先移除最少使用的键。"></a><strong>描述</strong>：在设置了过期时间的键中，优先移除最少使用的键。</h3></li>
<li><strong>适用场景</strong>：适用于只希望淘汰那些有过期时间的键，并保留无过期时间的数据的场景。</li>
</ul>
<h3 id="4-allkeys-random"><a href="#4-allkeys-random" class="headerlink" title="4. allkeys-random"></a>4. allkeys-random</h3><ul>
<li><strong>描述</strong>：在所有键中，随机选择一些键进行移除。</li>
<li><strong>适用场景</strong>：适用于不关心具体哪一部分数据被移除的场景。</li>
</ul>
<h3 id="5-volatile-random"><a href="#5-volatile-random" class="headerlink" title="5. volatile-random"></a>5. volatile-random</h3><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，随机选择一些键进行移除。</li>
<li><strong>适用场景</strong>：适用于只希望淘汰那些有过期时间的键，且不关心具体哪些键被移除的场景。</li>
</ul>
<h3 id="6-volatile-ttl"><a href="#6-volatile-ttl" class="headerlink" title="6. volatile-ttl"></a>6. volatile-ttl</h3><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先移除那些 TTL （剩余生存时间）较短的键。</li>
<li><strong>适用场景</strong>：适用于希望优先移除即将过期的键，以便保留有效期较长的键的场景。</li>
</ul>
<h3 id="7-allkeys-lfu-Redis-4-0-及以后版本"><a href="#7-allkeys-lfu-Redis-4-0-及以后版本" class="headerlink" title="7. allkeys-lfu (Redis 4.0 及以后版本)"></a>7. allkeys-lfu (Redis 4.0 及以后版本)</h3><ul>
<li><strong>描述</strong>：在所有键中，优先移除使用频率最少的键（Least Frequently Used）。</li>
<li><strong>适用场景</strong>：适用于希望保留访问频率较高的数据的场景。</li>
</ul>
<h3 id="8-volatile-lfu-Redis-4-0-及以后版本"><a href="#8-volatile-lfu-Redis-4-0-及以后版本" class="headerlink" title="8. volatile-lfu (Redis 4.0 及以后版本)"></a>8. volatile-lfu (Redis 4.0 及以后版本)</h3><ul>
<li><strong>描述</strong>：在设置了过期时间的键中，优先移除使用频率最少的键。</li>
<li><strong>适用场景</strong>：适用于希望在有过期时间的键中，保留访问频率较高的数据的场景。</li>
</ul>
<h3 id="配置缓存淘汰策略"><a href="#配置缓存淘汰策略" class="headerlink" title="配置缓存淘汰策略"></a>配置缓存淘汰策略</h3><p>可以在 Redis 配置文件 <code>redis.conf</code> 中设置缓存淘汰策略：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></tbody></table></figure>

<p>或者在运行时使用 <code>CONFIG SET</code> 命令设置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory-policy allkeys-lru</span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置最大内存限制"><a href="#配置最大内存限制" class="headerlink" title="配置最大内存限制"></a>配置最大内存限制</h3><p>同样地，可以在 <code>redis.conf</code> 中设置最大内存限制：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 256mb</span><br></pre></td></tr></tbody></table></figure>

<p>或者在运行时使用 <code>CONFIG SET</code> 命令设置：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET maxmemory 256mb</span><br></pre></td></tr></tbody></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 提供了多种缓存淘汰策略，以满足不同场景下的需求。通过合理配置缓存淘汰策略和最大内存限制，可以有效地管理 Redis 实例的内存使用，确保在内存限制达到时系统的稳定性和性能。</p>
<h1 id="3-redis的io多路复用是什么？"><a href="#3-redis的io多路复用是什么？" class="headerlink" title="3.redis的io多路复用是什么？"></a>3.redis的io多路复用是什么？</h1><h2 id="Redis的I-O多路复用是一种高效的网络事件处理机制，它允许Redis服务器同时处理多个连接而不会阻塞。多路复用（multiplexing）意味着Redis可以通过一个单一的线程同时监听多个文件描述符（如套接字），并在任何一个描述符变得可读或可写时，及时作出响应。这样，Redis就能够高效地管理大量的并发连接。"><a href="#Redis的I-O多路复用是一种高效的网络事件处理机制，它允许Redis服务器同时处理多个连接而不会阻塞。多路复用（multiplexing）意味着Redis可以通过一个单一的线程同时监听多个文件描述符（如套接字），并在任何一个描述符变得可读或可写时，及时作出响应。这样，Redis就能够高效地管理大量的并发连接。" class="headerlink" title="Redis的I/O多路复用是一种高效的网络事件处理机制，它允许Redis服务器同时处理多个连接而不会阻塞。多路复用（multiplexing）意味着Redis可以通过一个单一的线程同时监听多个文件描述符（如套接字），并在任何一个描述符变得可读或可写时，及时作出响应。这样，Redis就能够高效地管理大量的并发连接。"></a>Redis的I/O多路复用是一种高效的网络事件处理机制，它允许Redis服务器同时处理多个连接而不会阻塞。多路复用（multiplexing）意味着Redis可以通过一个单一的线程同时监听多个文件描述符（如套接字），并在任何一个描述符变得可读或可写时，及时作出响应。这样，Redis就能够高效地管理大量的并发连接。</h2><h2 id="Redis使用的是基于事件驱动的I-O多路复用模型，主要依赖操作系统提供的多路复用系统调用，例如："><a href="#Redis使用的是基于事件驱动的I-O多路复用模型，主要依赖操作系统提供的多路复用系统调用，例如：" class="headerlink" title="Redis使用的是基于事件驱动的I/O多路复用模型，主要依赖操作系统提供的多路复用系统调用，例如："></a>Redis使用的是基于事件驱动的I/O多路复用模型，主要依赖操作系统提供的多路复用系统调用，例如：</h2><ul>
<li><h2 id="select：这是一个最早的多路复用接口，但它有一些限制，比如文件描述符数量限制和性能问题。"><a href="#select：这是一个最早的多路复用接口，但它有一些限制，比如文件描述符数量限制和性能问题。" class="headerlink" title="select：这是一个最早的多路复用接口，但它有一些限制，比如文件描述符数量限制和性能问题。"></a><strong>select</strong>：这是一个最早的多路复用接口，但它有一些限制，比如文件描述符数量限制和性能问题。</h2></li>
<li><h2 id="poll：它克服了一些select的缺点，但在大多数情况下，仍然不如更现代的接口高效。"><a href="#poll：它克服了一些select的缺点，但在大多数情况下，仍然不如更现代的接口高效。" class="headerlink" title="poll：它克服了一些select的缺点，但在大多数情况下，仍然不如更现代的接口高效。"></a><strong>poll</strong>：它克服了一些select的缺点，但在大多数情况下，仍然不如更现代的接口高效。</h2></li>
<li><h2 id="epoll：这是Linux特有的接口，提供了更高效的事件通知机制，非常适合高并发场景。"><a href="#epoll：这是Linux特有的接口，提供了更高效的事件通知机制，非常适合高并发场景。" class="headerlink" title="epoll：这是Linux特有的接口，提供了更高效的事件通知机制，非常适合高并发场景。"></a><strong>epoll</strong>：这是Linux特有的接口，提供了更高效的事件通知机制，非常适合高并发场景。</h2></li>
<li><h2 id="kqueue：这是FreeBSD、OpenBSD、macOS等系统的多路复用接口，类似于epoll，但在不同的操作系统上提供了不同的实现。"><a href="#kqueue：这是FreeBSD、OpenBSD、macOS等系统的多路复用接口，类似于epoll，但在不同的操作系统上提供了不同的实现。" class="headerlink" title="kqueue：这是FreeBSD、OpenBSD、macOS等系统的多路复用接口，类似于epoll，但在不同的操作系统上提供了不同的实现。"></a><strong>kqueue</strong>：这是FreeBSD、OpenBSD、macOS等系统的多路复用接口，类似于epoll，但在不同的操作系统上提供了不同的实现。</h2></li>
</ul>
<h2 id="Redis内部会根据操作系统的类型和特性选择最合适的多路复用机制。具体工作流程如下："><a href="#Redis内部会根据操作系统的类型和特性选择最合适的多路复用机制。具体工作流程如下：" class="headerlink" title="Redis内部会根据操作系统的类型和特性选择最合适的多路复用机制。具体工作流程如下："></a>Redis内部会根据操作系统的类型和特性选择最合适的多路复用机制。具体工作流程如下：</h2><ol>
<li><h2 id="事件注册：Redis将感兴趣的I-O事件（如客户端连接的读写事件）注册到多路复用器。"><a href="#事件注册：Redis将感兴趣的I-O事件（如客户端连接的读写事件）注册到多路复用器。" class="headerlink" title="事件注册：Redis将感兴趣的I/O事件（如客户端连接的读写事件）注册到多路复用器。"></a><strong>事件注册</strong>：Redis将感兴趣的I/O事件（如客户端连接的读写事件）注册到多路复用器。</h2></li>
<li><h2 id="事件等待：多路复用器等待这些事件的发生。期间，Redis处于非阻塞状态，不会因为等待某个I-O事件而停滞。"><a href="#事件等待：多路复用器等待这些事件的发生。期间，Redis处于非阻塞状态，不会因为等待某个I-O事件而停滞。" class="headerlink" title="事件等待：多路复用器等待这些事件的发生。期间，Redis处于非阻塞状态，不会因为等待某个I/O事件而停滞。"></a><strong>事件等待</strong>：多路复用器等待这些事件的发生。期间，Redis处于非阻塞状态，不会因为等待某个I/O事件而停滞。</h2></li>
<li><h2 id="事件处理：一旦有I-O事件发生，多路复用器会将这些事件通知Redis，Redis则根据事件类型执行相应的处理，如读数据、写数据、接受新连接等。"><a href="#事件处理：一旦有I-O事件发生，多路复用器会将这些事件通知Redis，Redis则根据事件类型执行相应的处理，如读数据、写数据、接受新连接等。" class="headerlink" title="事件处理：一旦有I/O事件发生，多路复用器会将这些事件通知Redis，Redis则根据事件类型执行相应的处理，如读数据、写数据、接受新连接等。"></a><strong>事件处理</strong>：一旦有I/O事件发生，多路复用器会将这些事件通知Redis，Redis则根据事件类型执行相应的处理，如读数据、写数据、接受新连接等。</h2></li>
<li><h2 id="事件循环：上述过程在一个循环中反复进行，这就是Redis的事件循环机制，使得Redis能够高效地处理高并发的网络请求。"><a href="#事件循环：上述过程在一个循环中反复进行，这就是Redis的事件循环机制，使得Redis能够高效地处理高并发的网络请求。" class="headerlink" title="事件循环：上述过程在一个循环中反复进行，这就是Redis的事件循环机制，使得Redis能够高效地处理高并发的网络请求。"></a><strong>事件循环</strong>：上述过程在一个循环中反复进行，这就是Redis的事件循环机制，使得Redis能够高效地处理高并发的网络请求。</h2></li>
</ol>
<h1 id="这种机制的关键优势在于："><a href="#这种机制的关键优势在于：" class="headerlink" title="这种机制的关键优势在于："></a>这种机制的关键优势在于：</h1><ul>
<li><h2 id="高效：避免了线程切换和锁的开销，充分利用了单线程的性能。"><a href="#高效：避免了线程切换和锁的开销，充分利用了单线程的性能。" class="headerlink" title="高效：避免了线程切换和锁的开销，充分利用了单线程的性能。"></a><strong>高效</strong>：避免了线程切换和锁的开销，充分利用了单线程的性能。</h2></li>
<li><h2 id="可伸缩：能够轻松处理数以万计的并发连接，而不会显著增加资源消耗。"><a href="#可伸缩：能够轻松处理数以万计的并发连接，而不会显著增加资源消耗。" class="headerlink" title="可伸缩：能够轻松处理数以万计的并发连接，而不会显著增加资源消耗。"></a><strong>可伸缩</strong>：能够轻松处理数以万计的并发连接，而不会显著增加资源消耗。</h2></li>
<li><h2 id="简单：简化了代码逻辑，降低了复杂性和维护成本。"><a href="#简单：简化了代码逻辑，降低了复杂性和维护成本。" class="headerlink" title="简单：简化了代码逻辑，降低了复杂性和维护成本。"></a><strong>简单</strong>：简化了代码逻辑，降低了复杂性和维护成本。</h2></li>
</ul>
<h2 id="通过I-O多路复用，Redis实现了高效的网络通信能力，是其高性能的核心原因之一。"><a href="#通过I-O多路复用，Redis实现了高效的网络通信能力，是其高性能的核心原因之一。" class="headerlink" title="通过I/O多路复用，Redis实现了高效的网络通信能力，是其高性能的核心原因之一。"></a>通过I/O多路复用，Redis实现了高效的网络通信能力，是其高性能的核心原因之一。</h2><h1 id="4-redis集群的数据一致性你是怎么解决的？"><a href="#4-redis集群的数据一致性你是怎么解决的？" class="headerlink" title="4.redis集群的数据一致性你是怎么解决的？"></a>4.redis集群的数据一致性你是怎么解决的？</h1><h2 id="Redis集群在设计时面临数据一致性的问题，因为它在分布式环境下运行，需要确保数据的一致性和可靠性。Redis采用多种机制和策略来解决数据一致性问题，主要包括以下几个方面："><a href="#Redis集群在设计时面临数据一致性的问题，因为它在分布式环境下运行，需要确保数据的一致性和可靠性。Redis采用多种机制和策略来解决数据一致性问题，主要包括以下几个方面：" class="headerlink" title="Redis集群在设计时面临数据一致性的问题，因为它在分布式环境下运行，需要确保数据的一致性和可靠性。Redis采用多种机制和策略来解决数据一致性问题，主要包括以下几个方面："></a>Redis集群在设计时面临数据一致性的问题，因为它在分布式环境下运行，需要确保数据的一致性和可靠性。Redis采用多种机制和策略来解决数据一致性问题，主要包括以下几个方面：</h2><h2 id="1-数据复制"><a href="#1-数据复制" class="headerlink" title="1. 数据复制"></a>1. 数据复制</h2><h2 id="Redis集群通过主从复制（replication）来保证数据的高可用性和一致性。在Redis集群中，每个数据分片（shard）都有一个主节点（master）和若干个从节点（slave）。数据写入操作首先在主节点上执行，然后异步地复制到从节点。这样，即使某个主节点发生故障，从节点也可以提供数据访问，从而提高了数据的可用性和一致性。"><a href="#Redis集群通过主从复制（replication）来保证数据的高可用性和一致性。在Redis集群中，每个数据分片（shard）都有一个主节点（master）和若干个从节点（slave）。数据写入操作首先在主节点上执行，然后异步地复制到从节点。这样，即使某个主节点发生故障，从节点也可以提供数据访问，从而提高了数据的可用性和一致性。" class="headerlink" title="Redis集群通过主从复制（replication）来保证数据的高可用性和一致性。在Redis集群中，每个数据分片（shard）都有一个主节点（master）和若干个从节点（slave）。数据写入操作首先在主节点上执行，然后异步地复制到从节点。这样，即使某个主节点发生故障，从节点也可以提供数据访问，从而提高了数据的可用性和一致性。"></a>Redis集群通过主从复制（replication）来保证数据的高可用性和一致性。在Redis集群中，每个数据分片（shard）都有一个主节点（master）和若干个从节点（slave）。数据写入操作首先在主节点上执行，然后异步地复制到从节点。这样，即使某个主节点发生故障，从节点也可以提供数据访问，从而提高了数据的可用性和一致性。</h2><h2 id="2-一致性哈希"><a href="#2-一致性哈希" class="headerlink" title="2. 一致性哈希"></a>2. 一致性哈希</h2><h2 id="Redis集群采用一致性哈希算法来分配和定位数据。每个键根据哈希函数映射到一个特定的节点，这样可以确保键的分布较为均匀，并且在节点增加或减少时，只需重新映射少量键，减少了数据移动的范围，保持了集群的一致性。"><a href="#Redis集群采用一致性哈希算法来分配和定位数据。每个键根据哈希函数映射到一个特定的节点，这样可以确保键的分布较为均匀，并且在节点增加或减少时，只需重新映射少量键，减少了数据移动的范围，保持了集群的一致性。" class="headerlink" title="Redis集群采用一致性哈希算法来分配和定位数据。每个键根据哈希函数映射到一个特定的节点，这样可以确保键的分布较为均匀，并且在节点增加或减少时，只需重新映射少量键，减少了数据移动的范围，保持了集群的一致性。"></a>Redis集群采用一致性哈希算法来分配和定位数据。每个键根据哈希函数映射到一个特定的节点，这样可以确保键的分布较为均匀，并且在节点增加或减少时，只需重新映射少量键，减少了数据移动的范围，保持了集群的一致性。</h2><h2 id="3-故障转移（Failover）"><a href="#3-故障转移（Failover）" class="headerlink" title="3. 故障转移（Failover）"></a>3. 故障转移（Failover）</h2><h2 id="Redis集群具备自动故障转移功能。当检测到某个主节点故障时，集群会自动将该主节点的一个从节点提升为新的主节点，并重新分配客户端请求。这通过Redis-Sentinel机制来实现，Sentinel负责监控Redis节点的状态，并在检测到故障时执行故障转移操作，保证数据的一致性和可用性。"><a href="#Redis集群具备自动故障转移功能。当检测到某个主节点故障时，集群会自动将该主节点的一个从节点提升为新的主节点，并重新分配客户端请求。这通过Redis-Sentinel机制来实现，Sentinel负责监控Redis节点的状态，并在检测到故障时执行故障转移操作，保证数据的一致性和可用性。" class="headerlink" title="Redis集群具备自动故障转移功能。当检测到某个主节点故障时，集群会自动将该主节点的一个从节点提升为新的主节点，并重新分配客户端请求。这通过Redis Sentinel机制来实现，Sentinel负责监控Redis节点的状态，并在检测到故障时执行故障转移操作，保证数据的一致性和可用性。"></a>Redis集群具备自动故障转移功能。当检测到某个主节点故障时，集群会自动将该主节点的一个从节点提升为新的主节点，并重新分配客户端请求。这通过Redis Sentinel机制来实现，Sentinel负责监控Redis节点的状态，并在检测到故障时执行故障转移操作，保证数据的一致性和可用性。</h2><h2 id="4-配置共识协议"><a href="#4-配置共识协议" class="headerlink" title="4. 配置共识协议"></a>4. 配置共识协议</h2><h2 id="Redis集群使用Gossip协议来传播节点状态信息，使用集群配置共识协议（Cluster-Configuration-Agreement）来确保所有节点在配置变更时达成一致。这避免了因网络分区或其他原因导致的集群状态不一致问题。"><a href="#Redis集群使用Gossip协议来传播节点状态信息，使用集群配置共识协议（Cluster-Configuration-Agreement）来确保所有节点在配置变更时达成一致。这避免了因网络分区或其他原因导致的集群状态不一致问题。" class="headerlink" title="Redis集群使用Gossip协议来传播节点状态信息，使用集群配置共识协议（Cluster Configuration Agreement）来确保所有节点在配置变更时达成一致。这避免了因网络分区或其他原因导致的集群状态不一致问题。"></a>Redis集群使用Gossip协议来传播节点状态信息，使用集群配置共识协议（Cluster Configuration Agreement）来确保所有节点在配置变更时达成一致。这避免了因网络分区或其他原因导致的集群状态不一致问题。</h2><h2 id="5-客户端重定向"><a href="#5-客户端重定向" class="headerlink" title="5. 客户端重定向"></a>5. 客户端重定向</h2><h2 id="在Redis集群中，客户端可能会向错误的节点发送请求。为了解决这个问题，Redis集群通过ASK和MOVED重定向机制告知客户端请求的正确目标节点。客户端在收到重定向信息后，会重新路由请求到正确的节点，从而确保数据的一致性。"><a href="#在Redis集群中，客户端可能会向错误的节点发送请求。为了解决这个问题，Redis集群通过ASK和MOVED重定向机制告知客户端请求的正确目标节点。客户端在收到重定向信息后，会重新路由请求到正确的节点，从而确保数据的一致性。" class="headerlink" title="在Redis集群中，客户端可能会向错误的节点发送请求。为了解决这个问题，Redis集群通过ASK和MOVED重定向机制告知客户端请求的正确目标节点。客户端在收到重定向信息后，会重新路由请求到正确的节点，从而确保数据的一致性。"></a>在Redis集群中，客户端可能会向错误的节点发送请求。为了解决这个问题，Redis集群通过ASK和MOVED重定向机制告知客户端请求的正确目标节点。客户端在收到重定向信息后，会重新路由请求到正确的节点，从而确保数据的一致性。</h2><h2 id="6-写操作的传播和确认"><a href="#6-写操作的传播和确认" class="headerlink" title="6. 写操作的传播和确认"></a>6. 写操作的传播和确认</h2><h2 id="Redis集群通过部分同步（partial-synchronization）和心跳机制（heartbeat）来确保写操作在所有副本节点上的传播和确认。主节点会定期将写操作日志（Replication-Log）发送给从节点，从节点收到并确认后，主节点才会认为数据写入成功。"><a href="#Redis集群通过部分同步（partial-synchronization）和心跳机制（heartbeat）来确保写操作在所有副本节点上的传播和确认。主节点会定期将写操作日志（Replication-Log）发送给从节点，从节点收到并确认后，主节点才会认为数据写入成功。" class="headerlink" title="Redis集群通过部分同步（partial synchronization）和心跳机制（heartbeat）来确保写操作在所有副本节点上的传播和确认。主节点会定期将写操作日志（Replication Log）发送给从节点，从节点收到并确认后，主节点才会认为数据写入成功。"></a>Redis集群通过部分同步（partial synchronization）和心跳机制（heartbeat）来确保写操作在所有副本节点上的传播和确认。主节点会定期将写操作日志（Replication Log）发送给从节点，从节点收到并确认后，主节点才会认为数据写入成功。</h2><h2 id="7-数据持久化"><a href="#7-数据持久化" class="headerlink" title="7. 数据持久化"></a>7. 数据持久化</h2><h2 id="尽管Redis主要是内存数据库，但它也提供数据持久化选项（如RDB快照和AOF日志），以防止数据丢失。在集群环境下，每个节点可以独立进行持久化操作，确保即使发生崩溃或重启，数据也能得到恢复。"><a href="#尽管Redis主要是内存数据库，但它也提供数据持久化选项（如RDB快照和AOF日志），以防止数据丢失。在集群环境下，每个节点可以独立进行持久化操作，确保即使发生崩溃或重启，数据也能得到恢复。" class="headerlink" title="尽管Redis主要是内存数据库，但它也提供数据持久化选项（如RDB快照和AOF日志），以防止数据丢失。在集群环境下，每个节点可以独立进行持久化操作，确保即使发生崩溃或重启，数据也能得到恢复。"></a>尽管Redis主要是内存数据库，但它也提供数据持久化选项（如RDB快照和AOF日志），以防止数据丢失。在集群环境下，每个节点可以独立进行持久化操作，确保即使发生崩溃或重启，数据也能得到恢复。</h2><h2 id="通过上述机制，Redis集群能够在分布式环境下有效地解决数据一致性问题，提供高性能、高可用的数据服务。"><a href="#通过上述机制，Redis集群能够在分布式环境下有效地解决数据一致性问题，提供高性能、高可用的数据服务。" class="headerlink" title="通过上述机制，Redis集群能够在分布式环境下有效地解决数据一致性问题，提供高性能、高可用的数据服务。"></a>通过上述机制，Redis集群能够在分布式环境下有效地解决数据一致性问题，提供高性能、高可用的数据服务。</h2><h1 id="5-布隆过滤器是你自己写的还是第三方，自己写的误差知道是多少吗？有考虑过吗？"><a href="#5-布隆过滤器是你自己写的还是第三方，自己写的误差知道是多少吗？有考虑过吗？" class="headerlink" title="5.布隆过滤器是你自己写的还是第三方，自己写的误差知道是多少吗？有考虑过吗？"></a>5.布隆过滤器是你自己写的还是第三方，自己写的误差知道是多少吗？有考虑过吗？</h1><h2 id="布隆过滤器（Bloom-Filter）在Redis中是自行实现的，而不是使用第三方库。Redis模块提供了对布隆过滤器的支持，通过Redis的模块系统可以扩展功能，例如redis-bloom模块。"><a href="#布隆过滤器（Bloom-Filter）在Redis中是自行实现的，而不是使用第三方库。Redis模块提供了对布隆过滤器的支持，通过Redis的模块系统可以扩展功能，例如redis-bloom模块。" class="headerlink" title="布隆过滤器（Bloom Filter）在Redis中是自行实现的，而不是使用第三方库。Redis模块提供了对布隆过滤器的支持，通过Redis的模块系统可以扩展功能，例如redis-bloom模块。"></a>布隆过滤器（Bloom Filter）在Redis中是自行实现的，而不是使用第三方库。Redis模块提供了对布隆过滤器的支持，通过Redis的模块系统可以扩展功能，例如<code>redis-bloom</code>模块。</h2><h2 id="布隆过滤器的实现和误差率"><a href="#布隆过滤器的实现和误差率" class="headerlink" title="布隆过滤器的实现和误差率"></a>布隆过滤器的实现和误差率</h2><h2 id="布隆过滤器是一种空间效率极高的概率型数据结构，用于测试集合中是否存在一个元素。它能够显著减少存储空间，但允许一定的误判（false-positive），即可能报告一个不存在的元素为存在。"><a href="#布隆过滤器是一种空间效率极高的概率型数据结构，用于测试集合中是否存在一个元素。它能够显著减少存储空间，但允许一定的误判（false-positive），即可能报告一个不存在的元素为存在。" class="headerlink" title="布隆过滤器是一种空间效率极高的概率型数据结构，用于测试集合中是否存在一个元素。它能够显著减少存储空间，但允许一定的误判（false positive），即可能报告一个不存在的元素为存在。"></a>布隆过滤器是一种空间效率极高的概率型数据结构，用于测试集合中是否存在一个元素。它能够显著减少存储空间，但允许一定的误判（false positive），即可能报告一个不存在的元素为存在。</h2><h2 id="误差率的计算"><a href="#误差率的计算" class="headerlink" title="误差率的计算"></a>误差率的计算</h2><h2 id="布隆过滤器的误差率取决于以下几个因素："><a href="#布隆过滤器的误差率取决于以下几个因素：" class="headerlink" title="布隆过滤器的误差率取决于以下几个因素："></a>布隆过滤器的误差率取决于以下几个因素：</h2><ol>
<li><h2 id="哈希函数的数量（k）：哈希函数的数量影响误差率，通常通过优化选择一个合适的数量。"><a href="#哈希函数的数量（k）：哈希函数的数量影响误差率，通常通过优化选择一个合适的数量。" class="headerlink" title="哈希函数的数量（k）：哈希函数的数量影响误差率，通常通过优化选择一个合适的数量。"></a><strong>哈希函数的数量（k）</strong>：哈希函数的数量影响误差率，通常通过优化选择一个合适的数量。</h2></li>
<li><h2 id="位数组的大小（m）：位数组越大，误差率越低。"><a href="#位数组的大小（m）：位数组越大，误差率越低。" class="headerlink" title="位数组的大小（m）：位数组越大，误差率越低。"></a><strong>位数组的大小（m）</strong>：位数组越大，误差率越低。</h2></li>
<li><h2 id="插入元素的数量（n）：插入的元素越多，误差率越高。"><a href="#插入元素的数量（n）：插入的元素越多，误差率越高。" class="headerlink" title="插入元素的数量（n）：插入的元素越多，误差率越高。"></a><strong>插入元素的数量（n）</strong>：插入的元素越多，误差率越高。</h2></li>
</ol>
<h2 id="误差率可以通过以下公式计算："><a href="#误差率可以通过以下公式计算：" class="headerlink" title="误差率可以通过以下公式计算："></a>误差率可以通过以下公式计算：</h2><h2 id="P-f-left-1-left-1-frac-1-m-right-kn-right-k"><a href="#P-f-left-1-left-1-frac-1-m-right-kn-right-k" class="headerlink" title="[ P(f) = \left( 1 - \left( 1 - \frac{1}{m} \right)^{kn} \right)^k ]"></a>[ P(f) = \left( 1 - \left( 1 - \frac{1}{m} \right)^{kn} \right)^k ]</h2><h2 id="简化后，在位数组和哈希函数数量较大时，误差率近似为："><a href="#简化后，在位数组和哈希函数数量较大时，误差率近似为：" class="headerlink" title="简化后，在位数组和哈希函数数量较大时，误差率近似为："></a>简化后，在位数组和哈希函数数量较大时，误差率近似为：</h2><h2 id="P-f-approx-left-1-e-frac-kn-m-right-k"><a href="#P-f-approx-left-1-e-frac-kn-m-right-k" class="headerlink" title="[ P(f) \approx \left( 1 - e^{-\frac{kn}{m}} \right)^k ]"></a>[ P(f) \approx \left( 1 - e^{-\frac{kn}{m}} \right)^k ]</h2><h2 id="Redis布隆过滤器模块中的误差率"><a href="#Redis布隆过滤器模块中的误差率" class="headerlink" title="Redis布隆过滤器模块中的误差率"></a>Redis布隆过滤器模块中的误差率</h2><h2 id="在redis-bloom模块中，误差率是可配置的。用户可以在创建布隆过滤器时指定预期的误差率和预计插入的元素数量，模块会自动计算和分配适当的位数组大小和哈希函数数量以达到指定的误差率。例如："><a href="#在redis-bloom模块中，误差率是可配置的。用户可以在创建布隆过滤器时指定预期的误差率和预计插入的元素数量，模块会自动计算和分配适当的位数组大小和哈希函数数量以达到指定的误差率。例如：" class="headerlink" title="在redis-bloom模块中，误差率是可配置的。用户可以在创建布隆过滤器时指定预期的误差率和预计插入的元素数量，模块会自动计算和分配适当的位数组大小和哈希函数数量以达到指定的误差率。例如："></a>在<code>redis-bloom</code>模块中，误差率是可配置的。用户可以在创建布隆过滤器时指定预期的误差率和预计插入的元素数量，模块会自动计算和分配适当的位数组大小和哈希函数数量以达到指定的误差率。例如：</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BF.RESERVE myBloomFilter 0.01 10000</span><br></pre></td></tr></tbody></table></figure>

<h2 id="这条命令创建一个名为myBloomFilter的布隆过滤器，目标是存储10000个元素，目标误差率为1-。"><a href="#这条命令创建一个名为myBloomFilter的布隆过滤器，目标是存储10000个元素，目标误差率为1-。" class="headerlink" title="这条命令创建一个名为myBloomFilter的布隆过滤器，目标是存储10000个元素，目标误差率为1%。"></a>这条命令创建一个名为<code>myBloomFilter</code>的布隆过滤器，目标是存储10000个元素，目标误差率为1%。</h2><h2 id="实现误差率的考量"><a href="#实现误差率的考量" class="headerlink" title="实现误差率的考量"></a>实现误差率的考量</h2><h2 id="在设计和实现布隆过滤器时，Redis开发者考虑了以下几点："><a href="#在设计和实现布隆过滤器时，Redis开发者考虑了以下几点：" class="headerlink" title="在设计和实现布隆过滤器时，Redis开发者考虑了以下几点："></a>在设计和实现布隆过滤器时，Redis开发者考虑了以下几点：</h2><ol>
<li><h2 id="内存效率：尽量在保证误差率的前提下使用最少的内存。"><a href="#内存效率：尽量在保证误差率的前提下使用最少的内存。" class="headerlink" title="内存效率：尽量在保证误差率的前提下使用最少的内存。"></a><strong>内存效率</strong>：尽量在保证误差率的前提下使用最少的内存。</h2></li>
<li><h2 id="灵活配置：允许用户根据实际需求配置误差率和预计插入的元素数量。"><a href="#灵活配置：允许用户根据实际需求配置误差率和预计插入的元素数量。" class="headerlink" title="灵活配置：允许用户根据实际需求配置误差率和预计插入的元素数量。"></a><strong>灵活配置</strong>：允许用户根据实际需求配置误差率和预计插入的元素数量。</h2></li>
<li><h2 id="性能优化：优化哈希函数和位数组操作以提供高性能的查询和插入。"><a href="#性能优化：优化哈希函数和位数组操作以提供高性能的查询和插入。" class="headerlink" title="性能优化：优化哈希函数和位数组操作以提供高性能的查询和插入。"></a><strong>性能优化</strong>：优化哈希函数和位数组操作以提供高性能的查询和插入。</h2></li>
</ol>
<h2 id="实现中的误差率"><a href="#实现中的误差率" class="headerlink" title="实现中的误差率"></a>实现中的误差率</h2><h2 id="自定义实现布隆过滤器时，开发者通常需要实际测试和验证误差率。通过大量实验和实际使用情况来确认布隆过滤器的性能和误差率是否符合预期。这也是Redis开发团队在实现布隆过滤器时所进行的步骤。"><a href="#自定义实现布隆过滤器时，开发者通常需要实际测试和验证误差率。通过大量实验和实际使用情况来确认布隆过滤器的性能和误差率是否符合预期。这也是Redis开发团队在实现布隆过滤器时所进行的步骤。" class="headerlink" title="自定义实现布隆过滤器时，开发者通常需要实际测试和验证误差率。通过大量实验和实际使用情况来确认布隆过滤器的性能和误差率是否符合预期。这也是Redis开发团队在实现布隆过滤器时所进行的步骤。"></a>自定义实现布隆过滤器时，开发者通常需要实际测试和验证误差率。通过大量实验和实际使用情况来确认布隆过滤器的性能和误差率是否符合预期。这也是Redis开发团队在实现布隆过滤器时所进行的步骤。</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h2 id="Redis中的布隆过滤器是自实现的，并且在设计时充分考虑了误差率问题。通过灵活的配置和优化的实现，Redis能够在实际应用中提供高效且误差可控的布隆过滤器功能。如果需要了解具体的误差率或调整参数，用户可以参考Redis官方文档和相关模块文档。"><a href="#Redis中的布隆过滤器是自实现的，并且在设计时充分考虑了误差率问题。通过灵活的配置和优化的实现，Redis能够在实际应用中提供高效且误差可控的布隆过滤器功能。如果需要了解具体的误差率或调整参数，用户可以参考Redis官方文档和相关模块文档。" class="headerlink" title="Redis中的布隆过滤器是自实现的，并且在设计时充分考虑了误差率问题。通过灵活的配置和优化的实现，Redis能够在实际应用中提供高效且误差可控的布隆过滤器功能。如果需要了解具体的误差率或调整参数，用户可以参考Redis官方文档和相关模块文档。"></a>Redis中的布隆过滤器是自实现的，并且在设计时充分考虑了误差率问题。通过灵活的配置和优化的实现，Redis能够在实际应用中提供高效且误差可控的布隆过滤器功能。如果需要了解具体的误差率或调整参数，用户可以参考Redis官方文档和相关模块文档。</h2><h1 id="6-考虑过商品超卖问题的解决方式吗？"><a href="#6-考虑过商品超卖问题的解决方式吗？" class="headerlink" title="6.考虑过商品超卖问题的解决方式吗？"></a>6.考虑过商品超卖问题的解决方式吗？</h1><p>商品超卖（overselling）是电商和在线零售系统中常见的问题，特别是在高并发场景下，如秒杀活动或抢购。为了有效解决商品超卖问题，可以考虑以下几种方法：</p>
<h3 id="1-使用分布式锁"><a href="#1-使用分布式锁" class="headerlink" title="1. 使用分布式锁"></a>1. 使用分布式锁</h3><p>分布式锁可以保证同一时刻只有一个进程能够操作某一资源，从而避免超卖。Redis是实现分布式锁的常用工具。</p>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><p>使用Redis的<code>SETNX</code>（Set if Not Exists）命令来实现分布式锁。当用户请求购买商品时，先尝试获取锁，只有成功获取锁的用户才能继续购买流程。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock:product_id user_id</span><br></pre></td></tr></tbody></table></figure>

<p>如果获取成功（返回1），继续执行购买逻辑。购买完成后，释放锁：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL lock:product_id</span><br></pre></td></tr></tbody></table></figure>

<p>还可以结合<code>EXPIRE</code>设置锁的有效时间，防止死锁。</p>
<h3 id="2-原子操作"><a href="#2-原子操作" class="headerlink" title="2. 原子操作"></a>2. 原子操作</h3><p>使用数据库的原子操作可以确保库存扣减操作的原子性，避免超卖。</p>
<h4 id="基于Redis的原子操作"><a href="#基于Redis的原子操作" class="headerlink" title="基于Redis的原子操作"></a>基于Redis的原子操作</h4><p>Redis的<code>DECR</code>（Decrement）命令是原子操作，可以用来减少库存。当用户购买商品时，执行以下操作：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR product:stock</span><br></pre></td></tr></tbody></table></figure>

<p>如果结果小于0，则表示库存不足，需要回滚操作：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR product:stock</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h3><p>乐观锁基于版本号或时间戳实现，适合高并发场景下的超卖问题。</p>
<h4 id="基于Redis的乐观锁"><a href="#基于Redis的乐观锁" class="headerlink" title="基于Redis的乐观锁"></a>基于Redis的乐观锁</h4><p>使用<code>WATCH</code>命令监控库存键，然后执行事务操作（<code>MULTI</code>和<code>EXEC</code>）：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WATCH product:stock</span><br><span class="line">MULTI</span><br><span class="line">DECR product:stock</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>

<p>如果在<code>WATCH</code>后，库存键被其他客户端修改，<code>EXEC</code>操作会失败，需要重试。</p>
<h3 id="4-限流和队列"><a href="#4-限流和队列" class="headerlink" title="4. 限流和队列"></a>4. 限流和队列</h3><p>通过限流和队列机制控制请求的并发度，保证系统在高并发情况下的稳定性。</p>
<h4 id="基于消息队列"><a href="#基于消息队列" class="headerlink" title="基于消息队列"></a>基于消息队列</h4><p>可以使用消息队列（如RabbitMQ、Kafka等）将用户请求按照顺序排队处理。每次从队列中取出请求，处理完一个再处理下一个，从而避免超卖。</p>
<h3 id="5-数据库事务"><a href="#5-数据库事务" class="headerlink" title="5. 数据库事务"></a>5. 数据库事务</h3><p>在关系型数据库中，可以使用事务来确保库存更新的原子性。</p>
<h4 id="基于数据库事务的解决方案"><a href="#基于数据库事务的解决方案" class="headerlink" title="基于数据库事务的解决方案"></a>基于数据库事务的解决方案</h4><p>在MySQL等数据库中，可以使用事务来锁定行，确保操作的原子性和一致性。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> product_id <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 如果库存足够，更新库存</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> product_id;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-双写一致性"><a href="#6-双写一致性" class="headerlink" title="6. 双写一致性"></a>6. 双写一致性</h3><p>在复杂场景下，可以使用双写一致性策略，确保缓存和数据库的数据一致性，避免由于缓存不一致导致的超卖。</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>上述方法各有优缺点，根据具体业务场景和技术栈，选择合适的方案或组合使用，以确保商品在高并发场景下不会出现超卖问题。</p>
<ol>
<li><strong>分布式锁</strong>：适合需要严格顺序控制的场景，但可能有性能瓶颈。</li>
<li><strong>原子操作</strong>：高效且简单，但需要合理的库存设计。</li>
<li><strong>乐观锁</strong>：适合高并发下的库存扣减，但需要处理重试逻辑。</li>
<li><strong>限流和队列</strong>：能够有效控制并发量，确保系统稳定性。</li>
<li><strong>数据库事务</strong>：强一致性保证，但性能可能不如无锁方案。</li>
<li><strong>双写一致性</strong>：确保缓存和数据库一致，避免缓存不一致导致的问题。</li>
</ol>
<p>通过合理组合这些方案，可以有效解决商品超卖问题，确保系统的可靠性和用户体验。</p>
<h1 id="7-讲讲乐观锁？"><a href="#7-讲讲乐观锁？" class="headerlink" title="7.讲讲乐观锁？"></a>7.讲讲乐观锁？</h1><p>乐观锁是一种用于控制并发访问的机制，它假设多个事务在多数情况下不会互相干扰，因此不会在一开始就加锁，而是在提交更新时检查数据是否被其他事务修改过。如果发现数据被修改，则回滚当前事务并重试。这种策略特别适用于读操作多、写操作少的场景。</p>
<h3 id="乐观锁的实现原理"><a href="#乐观锁的实现原理" class="headerlink" title="乐观锁的实现原理"></a>乐观锁的实现原理</h3><p>乐观锁通常依赖于版本号或时间戳来实现。当对数据进行更新时，会检查当前版本号或时间戳是否与开始读取时的版本号或时间戳一致。如果一致，则执行更新；如果不一致，则说明数据已经被其他事务修改，当前操作需要重试。</p>
<h4 id="基于版本号的乐观锁"><a href="#基于版本号的乐观锁" class="headerlink" title="基于版本号的乐观锁"></a>基于版本号的乐观锁</h4><ol>
<li><strong>读取数据时</strong>，读取其版本号。</li>
<li><strong>更新数据时</strong>，检查当前版本号是否与读取时的一致。如果一致，则更新数据并将版本号加1；如果不一致，则说明数据已被修改，操作失败，需要重试。</li>
</ol>
<p>例如，在关系型数据库中可以这样实现：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 读取数据及版本号</span></span><br><span class="line"><span class="keyword">SELECT</span> stock, version <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新时检查版本号</span></span><br><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> 旧版本号;</span><br></pre></td></tr></tbody></table></figure>

<p>在Redis中，可以使用<code>WATCH</code>命令来实现类似的功能：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WATCH product:stock</span><br><span class="line">-- 获取库存和版本号</span><br><span class="line">MULTI</span><br><span class="line">DECR product:stock</span><br><span class="line">-- 提交事务</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>

<p>如果在<code>WATCH</code>命令之后，<code>product:stock</code>键被其他客户端修改，则<code>EXEC</code>命令执行时会失败，当前操作需要重试。</p>
<h3 id="乐观锁的优势"><a href="#乐观锁的优势" class="headerlink" title="乐观锁的优势"></a>乐观锁的优势</h3><ol>
<li><strong>高并发性能</strong>：因为不加锁，避免了锁争用和死锁问题，提高了系统的并发性能。</li>
<li><strong>适用读多写少的场景</strong>：在读操作多、写操作少的场景中，乐观锁的冲突概率较低，能发挥较高的性能优势。</li>
</ol>
<h3 id="乐观锁的局限性"><a href="#乐观锁的局限性" class="headerlink" title="乐观锁的局限性"></a>乐观锁的局限性</h3><ol>
<li><strong>重试机制</strong>：当并发写操作多时，乐观锁可能导致频繁的重试，影响系统性能。</li>
<li><strong>适用场景有限</strong>：乐观锁适用于读多写少的场景，如果写操作频繁，乐观锁的重试机制可能导致性能下降。</li>
<li><strong>实现复杂度</strong>：在一些复杂的业务逻辑中，实现乐观锁可能需要较多的额外工作，如管理版本号或时间戳。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol>
<li><strong>高并发系统</strong>：如电商平台的库存管理、用户账户余额更新等，尤其是在读操作多、写操作少的情况下。</li>
<li><strong>分布式系统</strong>：如分布式数据库或缓存系统，需要在多个节点之间保持数据的一致性。</li>
</ol>
<h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><p>以下是一个实际应用乐观锁的示例，假设我们有一个库存管理系统，在高并发情况下进行库存扣减操作：</p>
<h4 id="使用MySQL实现乐观锁"><a href="#使用MySQL实现乐观锁" class="headerlink" title="使用MySQL实现乐观锁"></a>使用MySQL实现乐观锁</h4><ol>
<li><strong>读取库存和版本号</strong>：</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock, version <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><strong>尝试更新库存和版本号</strong>：</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> 旧版本号;</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><strong>检查更新结果</strong>：<ul>
<li>如果更新成功，则说明库存扣减成功。</li>
<li>如果更新失败，则说明库存已被修改，需要重试。</li>
</ul>
</li>
</ol>
<h4 id="使用Redis实现乐观锁"><a href="#使用Redis实现乐观锁" class="headerlink" title="使用Redis实现乐观锁"></a>使用Redis实现乐观锁</h4><ol>
<li><strong>监控库存键</strong>：</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WATCH product:stock</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><strong>尝试扣减库存</strong>：</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">DECR product:stock</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><strong>检查事务结果</strong>：<ul>
<li>如果事务成功，则说明库存扣减成功。</li>
<li>如果事务失败，则说明库存已被修改，需要重试。</li>
</ul>
</li>
</ol>
<p>通过上述方式，可以在高并发场景下有效使用乐观锁，避免超卖等问题，同时保持较高的系统性能和可扩展性。</p>
<h2 id="8-你乐观锁是sql实现还是逻辑实现？"><a href="#8-你乐观锁是sql实现还是逻辑实现？" class="headerlink" title="8.你乐观锁是sql实现还是逻辑实现？"></a>8.你乐观锁是sql实现还是逻辑实现？</h2><p>乐观锁的实现方式可以根据具体需求和场景进行选择，可以是SQL实现，也可以是逻辑实现。两者各有优缺点，下面详细说明：</p>
<h3 id="SQL实现乐观锁"><a href="#SQL实现乐观锁" class="headerlink" title="SQL实现乐观锁"></a>SQL实现乐观锁</h3><p>SQL实现乐观锁主要通过数据库的支持，利用版本号或时间戳来保证数据的一致性。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li><p><strong>表结构设计</strong>：在需要使用乐观锁的表中添加一个版本号字段。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    stock <span class="type">INT</span>,</span><br><span class="line">    version <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>读取数据</strong>：读取数据时，获取当前版本号。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock, version <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>更新数据</strong>：更新数据时，检查版本号是否匹配。如果匹配，则更新数据并增加版本号；否则，更新失败。</p>
 <figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> products <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> old_version;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="逻辑实现乐观锁"><a href="#逻辑实现乐观锁" class="headerlink" title="逻辑实现乐观锁"></a>逻辑实现乐观锁</h3><p>逻辑实现乐观锁是在应用层通过代码逻辑来实现乐观锁的机制，适合需要更灵活控制的场景。</p>
<h4 id="基于Redis的逻辑实现"><a href="#基于Redis的逻辑实现" class="headerlink" title="基于Redis的逻辑实现"></a>基于Redis的逻辑实现</h4><ol>
<li><p><strong>监控数据</strong>：使用Redis的<code>WATCH</code>命令监控需要修改的键。</p>
 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WATCH product:stock</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>开始事务</strong>：在事务中执行需要的操作。</p>
 <figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">DECR product:stock</span><br><span class="line">EXEC</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>检查结果</strong>：如果事务执行成功，说明数据未被其他客户端修改。如果失败，需要重试。</p>
</li>
</ol>
<h4 id="基于代码的逻辑实现"><a href="#基于代码的逻辑实现" class="headerlink" title="基于代码的逻辑实现"></a>基于代码的逻辑实现</h4><ol>
<li><p><strong>读取数据和版本号</strong>：在应用逻辑中读取数据和其版本号。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productRepository.findById(productId);</span><br><span class="line"><span class="type">int</span> <span class="variable">currentVersion</span> <span class="operator">=</span> product.getVersion();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>执行更新</strong>：在更新时检查版本号。</p>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (productRepository.updateStock(productId, currentVersion) == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// 版本号不匹配，更新失败，需要重试</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockingFailureException</span>(<span class="string">"Data has been modified"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="优缺点比较"><a href="#优缺点比较" class="headerlink" title="优缺点比较"></a>优缺点比较</h3><h4 id="SQL实现"><a href="#SQL实现" class="headerlink" title="SQL实现"></a>SQL实现</h4><p><strong>优点</strong>：</p>
<ul>
<li>简单直接，依赖数据库的原生特性。</li>
<li>实现和维护成本低。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>数据库负载较高时，性能可能受影响。</li>
<li>跨多个数据库或分布式环境下实现较为困难。</li>
</ul>
<h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><p><strong>优点</strong>：</p>
<ul>
<li>灵活性高，可以跨数据库和分布式系统使用。</li>
<li>可以结合不同存储系统实现一致性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>实现复杂，增加了应用层的逻辑。</li>
<li>需要额外处理重试和失败的情况。</li>
</ul>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>SQL实现</strong>：适合单一数据库环境中较简单的应用场景，易于实现和维护。</li>
<li><strong>逻辑实现</strong>：适合复杂的、跨多个数据库或分布式系统的场景，提供更高的灵活性。</li>
</ul>
<p>具体选择哪种实现方式，取决于应用的架构、需求和复杂度。如果你的系统使用关系型数据库且对性能要求不高，可以选择SQL实现。如果你的系统是分布式架构，或者需要更灵活的控制，逻辑实现可能更适合。</p>
<h1 id="9-thread-local你为什么要用这个？"><a href="#9-thread-local你为什么要用这个？" class="headerlink" title="9.thread local你为什么要用这个？"></a>9.thread local你为什么要用这个？</h1><p><code>ThreadLocal</code>是Java中的一个工具类，它提供了线程本地变量。这些变量对每个使用该变量的线程都有独立的副本，线程之间互不干扰。这在某些特定场景下非常有用，可以用来简化线程安全问题的处理。</p>
<h3 id="为什么使用ThreadLocal？"><a href="#为什么使用ThreadLocal？" class="headerlink" title="为什么使用ThreadLocal？"></a>为什么使用<code>ThreadLocal</code>？</h3><ol>
<li><p><strong>线程安全</strong>：</p>
<ul>
<li>当多个线程需要独立地使用一些共享变量时，使用<code>ThreadLocal</code>可以避免并发问题。每个线程都有自己的变量副本，从而避免了线程间的竞争和同步问题。</li>
</ul>
</li>
<li><p><strong>简化代码</strong>：</p>
<ul>
<li>使用<code>ThreadLocal</code>可以避免显式的同步锁机制，简化代码的编写和维护。特别是在某些需要频繁访问共享变量的场景中，使用<code>ThreadLocal</code>可以使代码更加简洁和高效。</li>
</ul>
</li>
<li><p><strong>存储线程上下文信息</strong>：</p>
<ul>
<li><code>ThreadLocal</code>可以用于存储线程上下文信息，如数据库连接、用户会话信息等，使得这些信息在整个线程生命周期内都可以被方便地访问。</li>
</ul>
</li>
</ol>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><ol>
<li><p><strong>数据库连接</strong>：</p>
<ul>
<li>在多线程环境中，每个线程可能需要一个独立的数据库连接。使用<code>ThreadLocal</code>可以确保每个线程有自己的数据库连接，从而避免竞争和同步问题。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = </span><br><span class="line">        ThreadLocal.withInitial(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">            } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>事务管理</strong>：</p>
<ul>
<li>在分布式事务处理中，<code>ThreadLocal</code>可以用来保存事务上下文，使得事务操作在同一线程内可以访问到相同的事务信息。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Transaction&gt; transactionHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">        tx.begin();</span><br><span class="line">        transactionHolder.set(tx);</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commitTransaction</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionHolder.get();</span><br><span class="line">        <span class="keyword">if</span> (tx != <span class="literal">null</span>) {</span><br><span class="line">            tx.commit();</span><br><span class="line">            transactionHolder.remove();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollbackTransaction</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> transactionHolder.get();</span><br><span class="line">        <span class="keyword">if</span> (tx != <span class="literal">null</span>) {</span><br><span class="line">            tx.rollback();</span><br><span class="line">            transactionHolder.remove();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">getTransaction</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> transactionHolder.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>用户会话</strong>：</p>
<ul>
<li>在Web应用中，可以使用<code>ThreadLocal</code>来保存当前用户的会话信息，使得在整个请求处理过程中都能方便地访问用户信息。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; userHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(User user)</span> {</span><br><span class="line">        userHolder.set(user);</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getUser</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> userHolder.get();</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> {</span><br><span class="line">        userHolder.remove();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p><strong>内存泄漏</strong>：</p>
<ul>
<li>使用<code>ThreadLocal</code>时要特别注意内存泄漏问题。在应用服务器中，线程池中的线程可能会被重复使用。如果没有及时清理<code>ThreadLocal</code>变量，可能会导致内存泄漏。因此，在适当的时候要调用<code>remove()</code>方法来清理变量。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 使用 ThreadLocal 变量</span></span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    threadLocalVariable.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>复杂性</strong>：</p>
<ul>
<li>尽量简化<code>ThreadLocal</code>的使用，避免过度使用导致代码复杂和难以维护。<code>ThreadLocal</code>主要用于解决特定的线程安全问题，不应该作为解决所有并发问题的通用方案。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：</p>
<ul>
<li><code>ThreadLocal</code>适用于每个线程需要独立且一致地访问某些共享变量的场景。在大多数情况下，应优先考虑使用其他线程安全机制，如锁和并发容器。</li>
</ul>
</li>
</ol>
<p>通过合理使用<code>ThreadLocal</code>，可以有效解决特定场景下的线程安全问题，并简化代码的编写和维护。</p>
<h1 id="10-我们公司之前用这个出现过脏读问题，你变量是怎么清除？"><a href="#10-我们公司之前用这个出现过脏读问题，你变量是怎么清除？" class="headerlink" title="10.我们公司之前用这个出现过脏读问题，你变量是怎么清除？"></a>10.我们公司之前用这个出现过脏读问题，你变量是怎么清除？</h1><p>脏读（Dirty Read）是数据库并发控制中常见的问题之一，通常发生在未正确隔离事务的情况下。为了避免脏读问题，您需要确保事务隔离级别设置得当，并且在读取和写入数据时采取适当的措施。以下是一些方法和步骤，可以帮助您避免脏读问题：</p>
<ol>
<li><p><strong>设置事务隔离级别</strong>：</p>
<ul>
<li>选择适当的事务隔离级别可以显著减少脏读问题。最常见的隔离级别有四种：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和序列化（Serializable）。</li>
<li><strong>读已提交（Read Committed）</strong>：这是防止脏读的最常见隔离级别。它确保一个事务只能读取另一个事务已提交的数据。</li>
<li><strong>可重复读（Repeatable Read）</strong>和<strong>序列化（Serializable）</strong>：这两个级别提供了更高的隔离度，但可能会影响性能。</li>
</ul>
<p>在SQL中，设置隔离级别的示例：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>使用行级锁（Row-Level Locking）</strong>：</p>
<ul>
<li>确保在读取和写入数据时使用行级锁，而不是表级锁。行级锁可以减少并发访问时的冲突，从而避免脏读。</li>
<li>使用 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 来锁定读取的行。</li>
</ul>
</li>
<li><p><strong>乐观锁和悲观锁</strong>：</p>
<ul>
<li><strong>乐观锁</strong>：通常使用版本号或时间戳来控制并发。在读取数据时不加锁，但在更新时检查数据是否被修改过。</li>
<li><strong>悲观锁</strong>：在读取数据时直接加锁，确保其他事务不能修改数据，直到当前事务完成。</li>
</ul>
</li>
<li><p><strong>事务管理</strong>：</p>
<ul>
<li>确保事务在适当的时间提交或回滚。避免长时间未提交的事务，这会增加发生脏读的风险。</li>
<li>使用事务时，确保每个事务的作用范围清晰且尽量短。</li>
</ul>
</li>
<li><p><strong>数据库设置</strong>：</p>
<ul>
<li>检查和调整数据库的配置，确保其默认的隔离级别符合您的应用需求。例如，在MySQL中，可以通过配置文件或动态设置更改隔离级别。</li>
</ul>
</li>
<li><p><strong>编程实践</strong>：</p>
<ul>
<li>在代码中确保每个数据库操作都在适当的事务范围内。</li>
<li>使用一致的数据库访问模式，确保读写操作的顺序和隔离性。</li>
</ul>
</li>
</ol>
<p>以下是一个代码示例，展示如何在Java中使用JDBC设置事务隔离级别：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 关闭自动提交</span></span><br><span class="line">    conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); <span class="comment">// 设置事务隔离级别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">"SELECT * FROM my_table WHERE id = 1 FOR UPDATE"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果集</span></span><br><span class="line">    <span class="keyword">if</span> (rs.next()) {</span><br><span class="line">        <span class="comment">// 更新操作</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            conn.rollback(); <span class="comment">// 回滚事务</span></span><br><span class="line">        } <span class="keyword">catch</span> (SQLException ex) {</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            conn.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">        } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过以上方法，可以有效避免脏读问题，提高系统的并发处理能力和数据一致性。</p>
<h1 id="11-讲讲threadlocal的底层原理。"><a href="#11-讲讲threadlocal的底层原理。" class="headerlink" title="11.讲讲threadlocal的底层原理。"></a>11.讲讲threadlocal的底层原理。</h1><p><code>ThreadLocal</code> 是 Java 提供的一种机制，用于为每个线程提供独立的变量副本，使每个线程都可以独立地修改自己的变量副本，而不会影响其他线程的变量副本。<code>ThreadLocal</code> 的主要作用是避免线程间共享数据，从而防止线程间的数据竞争问题。了解 <code>ThreadLocal</code> 的底层原理可以帮助我们更好地使用它并避免潜在的问题。</p>
<h3 id="ThreadLocal-的基本用法"><a href="#ThreadLocal-的基本用法" class="headerlink" title="ThreadLocal 的基本用法"></a><code>ThreadLocal</code> 的基本用法</h3><p>以下是一个简单的 <code>ThreadLocal</code> 使用示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; {</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" initial value: "</span> + value);</span><br><span class="line">            threadLocal.set(value + <span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" updated value: "</span> + threadLocal.get());</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">"Thread-1"</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">"Thread-2"</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ThreadLocal-的底层原理"><a href="#ThreadLocal-的底层原理" class="headerlink" title="ThreadLocal 的底层原理"></a><code>ThreadLocal</code> 的底层原理</h3><p><code>ThreadLocal</code> 的工作机制主要依赖于每个线程内部维护的一个 <code>ThreadLocalMap</code> 实例。每个线程有一个自己的 <code>ThreadLocalMap</code>，这个 <code>ThreadLocalMap</code> 通过 <code>ThreadLocal</code> 对象作为键来存储线程的私有变量。</p>
<h4 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h4><ol>
<li><p><strong>Thread 类</strong>：<br><code>Thread</code> 类中有一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的字段 <code>threadLocals</code>，用于存储该线程的所有 <code>ThreadLocal</code> 变量。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Other fields and methods...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>ThreadLocal 类</strong>：<br><code>ThreadLocal</code> 类的每个实例实际上对应一个键值对，其中键是 <code>ThreadLocal</code> 自身，值是具体的变量值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; {</span><br><span class="line">    <span class="comment">// 内部静态类，用于存储键值对</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> {</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">            Object value;</span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// ThreadLocalMap 的具体实现</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="comment">// 在 map 中查找当前 ThreadLocal 对应的值</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 返回值或初始化值</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> {</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ol>
<li><p><strong>存取数据</strong>：<br>每次调用 <code>ThreadLocal</code> 的 <code>get</code> 或 <code>set</code> 方法时，<code>ThreadLocal</code> 会首先获取当前线程（通过 <code>Thread.currentThread()</code>）。然后，它会检查这个线程是否已经有一个 <code>ThreadLocalMap</code>。如果没有，它会创建一个新的 <code>ThreadLocalMap</code>。</p>
</li>
<li><p><strong>存储数据</strong>：<br><code>ThreadLocalMap</code> 是一个定制的哈希表结构，键是 <code>ThreadLocal</code> 实例，值是实际的数据。在存储数据时，<code>ThreadLocal</code> 使用自身作为键，将数据存储到当前线程的 <code>ThreadLocalMap</code> 中。</p>
</li>
<li><p><strong>垃圾回收</strong>：<br><code>ThreadLocalMap</code> 中的键（<code>ThreadLocal</code> 实例）是弱引用（<code>WeakReference</code>）。这意味着，如果一个 <code>ThreadLocal</code> 实例没有其他强引用，它可以被垃圾回收。这可以防止内存泄漏，但也需要用户在不需要时显式地调用 <code>remove</code> 方法来清除数据。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) {</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>虽然 <code>ThreadLocal</code> 设计时考虑了内存泄漏问题，但实际使用中如果不慎重仍可能导致内存泄漏。因为 <code>ThreadLocalMap</code> 的值部分是强引用，如果没有显式地删除 <code>ThreadLocal</code> 变量，当线程长时间存在时，其对应的 <code>ThreadLocal</code> 变量及其值将不会被回收。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>ThreadLocal</code> 提供了一种方便的方式来实现线程本地存储，每个线程都可以拥有自己独立的变量副本而不影响其他线程。这种机制在实现简单的线程隔离时非常有用，但需要谨慎使用，特别是在长生命周期的线程（如线程池中的线程）中，应该在不需要时显式地清除 <code>ThreadLocal</code> 变量，以避免内存泄漏。</p>
<h1 id="12-浮点数精度丢失问题考虑过吗？"><a href="#12-浮点数精度丢失问题考虑过吗？" class="headerlink" title="12.浮点数精度丢失问题考虑过吗？"></a>12.浮点数精度丢失问题考虑过吗？</h1><p>浮点数精度丢失问题是计算机科学中的一个常见问题，尤其在处理金融计算、科学计算和图形渲染等领域时。浮点数在计算机中是以二进制形式表示的，而很多十进制的小数无法用有限的二进制位精确表示，从而导致精度丢失。</p>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3><p>在计算机中，浮点数通常使用 IEEE 754 标准表示，包括单精度（32位）和双精度（64位）：</p>
<ul>
<li><strong>单精度浮点数（32位）</strong>：1位符号位，8位指数位，23位尾数位。</li>
<li><strong>双精度浮点数（64位）</strong>：1位符号位，11位指数位，52位尾数位。</li>
</ul>
<p>由于位数有限，某些数值（例如，0.1 或 1/3）无法精确表示，只能近似表示，从而导致精度丢失。</p>
<h3 id="常见的精度丢失问题"><a href="#常见的精度丢失问题" class="headerlink" title="常见的精度丢失问题"></a>常见的精度丢失问题</h3><ol>
<li><p><strong>简单的十进制小数表示问题</strong>：</p>
<ul>
<li>十进制数 0.1 在二进制中是一个无限循环小数，无法精确表示。因此，用浮点数表示 0.1 时，实际存储的是一个近似值。</li>
</ul>
</li>
<li><p><strong>累积误差</strong>：</p>
<ul>
<li>在多次运算中，精度误差可能累积，导致结果与期望值偏差较大。例如，循环加法操作中，每次小的误差可能在多次运算后累积成较大的误差。</li>
</ul>
</li>
<li><p><strong>舍入误差</strong>：</p>
<ul>
<li>当两个浮点数相加时，较小的数可能被舍入而导致丢失。例如，1.0 + 1e-17 可能依然等于 1.0。</li>
</ul>
</li>
<li><p><strong>比较误差</strong>：</p>
<ul>
<li>由于浮点数的精度问题，直接比较两个浮点数的相等性可能会出错。通常使用一个很小的阈值（如 epsilon）来判断两个浮点数是否接近。</li>
</ul>
</li>
</ol>
<h3 id="解决精度丢失的方法"><a href="#解决精度丢失的方法" class="headerlink" title="解决精度丢失的方法"></a>解决精度丢失的方法</h3><ol>
<li><p><strong>使用高精度库</strong>：</p>
<ul>
<li>在需要高精度计算的场合，可以使用大数或高精度浮点数库。例如，Java 中的 <code>BigDecimal</code>，Python 中的 <code>decimal</code> 模块，C++ 中的 <code>Boost.Multiprecision</code>。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.1"</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.2"</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">System.out.println(c); <span class="comment">// 输出 0.3</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>避免累积误差</strong>：</p>
<ul>
<li>对于需要多次累加的操作，使用更高精度的数据类型或者通过重新排序运算顺序来减少误差累积。</li>
</ul>
</li>
<li><p><strong>使用适当的舍入模式</strong>：</p>
<ul>
<li>在进行四舍五入操作时，使用适当的舍入模式来减少误差。例如，<code>BigDecimal</code> 提供了多种舍入模式可供选择。</li>
</ul>
</li>
<li><p><strong>比较浮点数时使用阈值</strong>：</p>
<ul>
<li>比较浮点数时，使用一个很小的阈值来判断它们是否足够接近。</li>
</ul>
 <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areAlmostEqual</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> epsilon)</span> {</span><br><span class="line">    <span class="keyword">return</span> Math.abs(a - b) &lt; epsilon;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> * <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.3</span>;</span><br><span class="line">System.out.println(areAlmostEqual(a, b, <span class="number">1e-10</span>)); <span class="comment">// 输出 true</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个示例，展示了如何使用 <code>BigDecimal</code> 解决浮点数精度丢失问题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrecisionExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(<span class="string">"Using double: "</span> + c); <span class="comment">// 输出 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.1"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.2"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd3</span> <span class="operator">=</span> bd1.add(bd2);</span><br><span class="line">        System.out.println(<span class="string">"Using BigDecimal: "</span> + bd3); <span class="comment">// 输出 0.3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>浮点数精度丢失是计算机科学中不可避免的问题，但可以通过使用高精度计算库、合理的运算方法和比较策略来减少和控制误差。了解浮点数的表示和运算机制是解决精度问题的基础。</p>
<h1 id="13-浮点数为什么会精度丢失，讲讲底层？"><a href="#13-浮点数为什么会精度丢失，讲讲底层？" class="headerlink" title="13.浮点数为什么会精度丢失，讲讲底层？"></a>13.浮点数为什么会精度丢失，讲讲底层？</h1><p>浮点数精度丢失的根本原因在于计算机中浮点数的表示方式和实际计算过程。计算机使用二进制（base-2）表示浮点数，而许多十进制（base-10）小数无法用有限的二进制位精确表示，从而导致精度丢失。</p>
<h3 id="浮点数的表示方式"><a href="#浮点数的表示方式" class="headerlink" title="浮点数的表示方式"></a>浮点数的表示方式</h3><p>浮点数通常使用 IEEE 754 标准表示，这个标准定义了浮点数的二进制表示方法。浮点数由三个部分组成：</p>
<ol>
<li><strong>符号位（Sign bit）</strong>：决定浮点数的正负，0 表示正数，1 表示负数。</li>
<li><strong>指数部分（Exponent）</strong>：表示浮点数的规模（即数值的范围）。</li>
<li><strong>尾数部分（Mantissa or Significand）</strong>：表示浮点数的精度（即数值的精确度）。</li>
</ol>
<h4 id="单精度浮点数（32位）"><a href="#单精度浮点数（32位）" class="headerlink" title="单精度浮点数（32位）"></a>单精度浮点数（32位）</h4><ul>
<li>1位符号位</li>
<li>8位指数位（用于存储指数，采用偏移量为 127 的偏置表示）</li>
<li>23位尾数位</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1)^sign * 1.mantissa * 2^(exponent - 127)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="双精度浮点数（64位）"><a href="#双精度浮点数（64位）" class="headerlink" title="双精度浮点数（64位）"></a>双精度浮点数（64位）</h4><ul>
<li>1位符号位</li>
<li>11位指数位（偏移量为 1023）</li>
<li>52位尾数位</li>
</ul>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1)^sign * 1.mantissa * 2^(exponent - 1023)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="精度丢失的原因"><a href="#精度丢失的原因" class="headerlink" title="精度丢失的原因"></a>精度丢失的原因</h3><ol>
<li><p><strong>有限的尾数位</strong>：</p>
<ul>
<li>由于尾数位的数量有限，很多十进制小数在二进制中无法精确表示，只能近似表示。例如，十进制的 0.1 在二进制中是一个无限循环小数，其二进制表示为 0.000110011001100110011001100110011…（循环节为 0011）。因为位数有限，计算机会截断这个表示，从而导致近似值。</li>
</ul>
</li>
<li><p><strong>二进制和十进制的差异</strong>：</p>
<ul>
<li>很多十进制的小数在二进制中无法精确表示，因为二进制只能精确表示分母为 2 的幂的分数。例如，1/2、1/4、1/8 可以精确表示，而 1/3、1/5、0.1 则无法精确表示。</li>
</ul>
</li>
<li><p><strong>舍入误差</strong>：</p>
<ul>
<li>当两个浮点数进行运算（如加法、减法、乘法、除法）时，结果可能需要舍入到可表示的位数范围内。这种舍入会引入额外的误差，尤其在多次运算累积时，这种误差会显著增加。</li>
</ul>
</li>
</ol>
<h3 id="浮点数运算中的具体例子"><a href="#浮点数运算中的具体例子" class="headerlink" title="浮点数运算中的具体例子"></a>浮点数运算中的具体例子</h3><h4 id="示例：0-1-0-2"><a href="#示例：0-1-0-2" class="headerlink" title="示例：0.1 + 0.2"></a>示例：0.1 + 0.2</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloatPrecision</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c); <span class="comment">// 输出 0.30000000000000004</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>0.1 和 0.2 的二进制表示</strong>：</p>
<ul>
<li>0.1 在二进制中近似表示为 0.000110011001100110011001100110011…</li>
<li>0.2 在二进制中近似表示为 0.001100110011001100110011001100110…</li>
</ul>
</li>
<li><p><strong>运算过程中的舍入</strong>：</p>
<ul>
<li>当 0.1 和 0.2 进行加法运算时，计算机会进行二进制加法。由于位数限制，结果会被截断或舍入，从而导致最终结果不完全准确。</li>
</ul>
</li>
<li><p><strong>结果的二进制表示</strong>：</p>
<ul>
<li>加法运算后的二进制结果为 0.010011001100110011001100110011001…，转换回十进制大约为 0.30000000000000004。</li>
</ul>
</li>
</ol>
<h3 id="如何减少精度丢失"><a href="#如何减少精度丢失" class="headerlink" title="如何减少精度丢失"></a>如何减少精度丢失</h3><ol>
<li><p><strong>使用高精度数据类型</strong>：</p>
<ul>
<li>在需要高精度计算的场合，可以使用高精度库，如 Java 的 <code>BigDecimal</code>，Python 的 <code>decimal</code> 模块等。</li>
</ul>
</li>
<li><p><strong>适当的舍入策略</strong>：</p>
<ul>
<li>选择合适的舍入策略来控制运算误差，例如四舍五入、向零舍入等。</li>
</ul>
</li>
<li><p><strong>分段计算</strong>：</p>
<ul>
<li>对于累积误差较大的计算，尽量分段计算，并在中间进行舍入和调整。</li>
</ul>
</li>
<li><p><strong>避免直接比较</strong>：</p>
<ul>
<li>在比较两个浮点数时，使用一个小的阈值（如 epsilon）来判断它们是否接近，而不是直接比较相等。</li>
</ul>
</li>
</ol>
<h3 id="示例：使用-BigDecimal"><a href="#示例：使用-BigDecimal" class="headerlink" title="示例：使用 BigDecimal"></a>示例：使用 <code>BigDecimal</code></h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.1"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.2"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        System.out.println(c); <span class="comment">// 输出 0.3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过理解浮点数的底层表示和运算机制，我们可以更好地应对浮点数精度丢失问题，并在需要高精度计算时选择合适的解决方案。</p>
<h1 id="14-如何解决精度丢失问题？"><a href="#14-如何解决精度丢失问题？" class="headerlink" title="14.如何解决精度丢失问题？"></a>14.如何解决精度丢失问题？</h1><p>解决浮点数精度丢失问题的主要方法包括使用高精度数据类型、适当的舍入策略、分段计算以及避免直接比较等。以下是详细的解决方案和代码示例：</p>
<h3 id="1-使用高精度数据类型"><a href="#1-使用高精度数据类型" class="headerlink" title="1. 使用高精度数据类型"></a>1. 使用高精度数据类型</h3><p>在需要高精度计算的场合，可以使用高精度库，如 Java 的 <code>BigDecimal</code>、Python 的 <code>decimal</code> 模块等。这些库能够精确表示和计算十进制数。</p>
<h4 id="Java-示例"><a href="#Java-示例" class="headerlink" title="Java 示例"></a>Java 示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.1"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.2"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        System.out.println(c); <span class="comment">// 输出 0.3</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Python-示例"><a href="#Python-示例" class="headerlink" title="Python 示例"></a>Python 示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">'0.1'</span>)</span><br><span class="line">b = Decimal(<span class="string">'0.2'</span>)</span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(c)  <span class="comment"># 输出 0.3</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-使用适当的舍入策略"><a href="#2-使用适当的舍入策略" class="headerlink" title="2. 使用适当的舍入策略"></a>2. 使用适当的舍入策略</h3><p>在进行浮点数运算时，可以使用适当的舍入策略来控制误差。常见的舍入模式有：四舍五入、向上舍入、向下舍入等。</p>
<h4 id="Java-示例-1"><a href="#Java-示例-1" class="headerlink" title="Java 示例"></a>Java 示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundingExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">"0.3333"</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">rounded</span> <span class="operator">=</span> a.setScale(<span class="number">2</span>, RoundingMode.HALF_UP);</span><br><span class="line">        System.out.println(rounded); <span class="comment">// 输出 0.33</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-分段计算"><a href="#3-分段计算" class="headerlink" title="3. 分段计算"></a>3. 分段计算</h3><p>对于累积误差较大的计算，可以将计算分段进行，并在中间进行舍入和调整，减少误差的积累。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentedCalculation</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">            sum += <span class="number">0.1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) {</span><br><span class="line">                sum = Math.round(sum * <span class="number">1e10</span>) / <span class="number">1e10</span>; <span class="comment">// 中间舍入</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(sum); <span class="comment">// 输出接近预期结果</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-避免直接比较"><a href="#4-避免直接比较" class="headerlink" title="4. 避免直接比较"></a>4. 避免直接比较</h3><p>在比较两个浮点数时，使用一个小的阈值（如 epsilon）来判断它们是否接近，而不是直接比较相等。</p>
<h4 id="Java-示例-2"><a href="#Java-示例-2" class="headerlink" title="Java 示例"></a>Java 示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FloatComparison</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">areAlmostEqual</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> epsilon)</span> {</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a - b) &lt; epsilon;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.3</span>;</span><br><span class="line">        System.out.println(areAlmostEqual(a, b, <span class="number">1e-10</span>)); <span class="comment">// 输出 true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Python-示例-1"><a href="#Python-示例-1" class="headerlink" title="Python 示例"></a>Python 示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">are_almost_equal</span>(<span class="params">a, b, epsilon</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a - b) &lt; epsilon</span><br><span class="line"></span><br><span class="line">a = <span class="number">0.1</span> * <span class="number">3</span></span><br><span class="line">b = <span class="number">0.3</span></span><br><span class="line"><span class="built_in">print</span>(are_almost_equal(a, b, <span class="number">1e-10</span>))  <span class="comment"># 输出 True</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="5-使用专门的库和数据结构"><a href="#5-使用专门的库和数据结构" class="headerlink" title="5. 使用专门的库和数据结构"></a>5. 使用专门的库和数据结构</h3><p>在特定领域（如金融计算），使用专门设计的库和数据结构可以有效解决精度问题。例如，金融计算中常用的库 <code>Joda-Money</code> 或 <code>Money</code> 库，可以处理货币和金融数值的精度问题。</p>
<h4 id="Java-示例-3"><a href="#Java-示例-3" class="headerlink" title="Java 示例"></a>Java 示例</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.joda.money.CurrencyUnit;</span><br><span class="line"><span class="keyword">import</span> org.joda.money.Money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JodaMoneyExample</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Money</span> <span class="variable">a</span> <span class="operator">=</span> Money.of(CurrencyUnit.USD, <span class="number">0.1</span>);</span><br><span class="line">        <span class="type">Money</span> <span class="variable">b</span> <span class="operator">=</span> Money.of(CurrencyUnit.USD, <span class="number">0.2</span>);</span><br><span class="line">        <span class="type">Money</span> <span class="variable">c</span> <span class="operator">=</span> a.plus(b);</span><br><span class="line">        System.out.println(c); <span class="comment">// 输出 USD 0.30</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这些方法，我们可以有效减少或避免浮点数精度丢失问题，在需要高精度计算的场合下保证计算结果的准确性。</p>
<h1 id="15-jwt验证流程？"><a href="#15-jwt验证流程？" class="headerlink" title="15.jwt验证流程？"></a>15.jwt验证流程？</h1><p>JSON Web Token (JWT) 是一种基于 JSON 的开放标准（RFC 7519）实现，用于在网络应用环境中传递声明。JWT 通常用于认证和授权。以下是 JWT 验证流程的详细说明：</p>
<h3 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h3><p>一个 JWT 由三个部分组成，每部分之间用点 (<code>.</code>) 分隔：</p>
<ol>
<li><strong>Header</strong>：头部</li>
<li><strong>Payload</strong>：负载</li>
<li><strong>Signature</strong>：签名</li>
</ol>
<p>示例 JWT：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-Header（头部）"><a href="#1-Header（头部）" class="headerlink" title="1. Header（头部）"></a>1. Header（头部）</h3><p>头部通常由两部分组成：类型（即 JWT）和签名算法（如 HMAC SHA256 或 RSA）。</p>
<p>示例：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"alg"</span><span class="punctuation">:</span> <span class="string">"HS256"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"typ"</span><span class="punctuation">:</span> <span class="string">"JWT"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个 JSON 结构被编码为 Base64Url。</p>
<h3 id="2-Payload（负载）"><a href="#2-Payload（负载）" class="headerlink" title="2. Payload（负载）"></a>2. Payload（负载）</h3><p>负载部分包含声明（claims）。声明有三种类型：registered、public 和 private。</p>
<p>示例：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"iat"</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个 JSON 结构也被编码为 Base64Url。</p>
<h3 id="3-Signature（签名）"><a href="#3-Signature（签名）" class="headerlink" title="3. Signature（签名）"></a>3. Signature（签名）</h3><p>为了创建签名，您需要对编码后的 header 和 payload 进行签名：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>签名用于验证消息在传输过程中是否未被篡改。</p>
<h3 id="JWT-验证流程"><a href="#JWT-验证流程" class="headerlink" title="JWT 验证流程"></a>JWT 验证流程</h3><ol>
<li><p><strong>客户端请求认证</strong>：</p>
<ul>
<li>用户通过登录页面输入用户名和密码。</li>
<li>服务器验证用户的凭据。如果验证成功，服务器生成 JWT 并将其返回给客户端。</li>
</ul>
</li>
<li><p><strong>客户端存储 JWT</strong>：</p>
<ul>
<li>客户端（通常是浏览器）收到 JWT 后，将其存储在本地存储或 cookie 中。</li>
</ul>
</li>
<li><p><strong>客户端请求受保护资源</strong>：</p>
<ul>
<li>客户端在后续请求中将 JWT 添加到 HTTP 请求头中（通常是 <code>Authorization</code> 头部，格式为 <code>Bearer &lt;token&gt;</code>）。</li>
</ul>
</li>
<li><p><strong>服务器验证 JWT</strong>：</p>
<ul>
<li>服务器接收到客户端请求后，提取 JWT 并进行验证。</li>
<li>验证步骤包括：<ol>
<li><strong>检查签名</strong>：<ul>
<li>使用服务器端的密钥（对称加密）或公钥（非对称加密）验证签名是否正确。</li>
</ul>
</li>
<li><strong>解码 JWT</strong>：<ul>
<li>解码 Base64Url 编码的 header 和 payload，检查 JWT 的结构是否正确。</li>
</ul>
</li>
<li><strong>验证声明</strong>：<ul>
<li>验证标准声明（如 <code>iss</code>、<code>exp</code>、<code>sub</code> 等），确保 token 未过期且符合预期。</li>
</ul>
</li>
<li><strong>检查权限</strong>：<ul>
<li>根据负载中的声明，检查用户是否有权限访问请求的资源。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>响应客户端请求</strong>：</p>
<ul>
<li>如果 JWT 验证成功，服务器处理请求并返回受保护的资源。</li>
<li>如果 JWT 验证失败，服务器返回适当的错误信息（如 401 未授权）。</li>
</ul>
</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的 JWT 验证示例，使用 JavaScript 和 Node.js：</p>
<h4 id="创建和验证-JWT"><a href="#创建和验证-JWT" class="headerlink" title="创建和验证 JWT"></a>创建和验证 JWT</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥</span></span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">'your-256-bit-secret'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 JWT</span></span><br><span class="line"><span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>({ <span class="attr">sub</span>: <span class="string">'1234567890'</span>, <span class="attr">name</span>: <span class="string">'John Doe'</span>, <span class="attr">iat</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() / <span class="number">1000</span>) - <span class="number">30</span> }, secret);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Token:'</span>, token);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 JWT</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">  <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, secret);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Decoded:'</span>, decoded);</span><br><span class="line">} <span class="keyword">catch</span> (err) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">'Invalid token:'</span>, err.<span class="property">message</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="在-Express-js-中验证-JWT"><a href="#在-Express-js-中验证-JWT" class="headerlink" title="在 Express.js 中验证 JWT"></a>在 Express.js 中验证 JWT</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">'your-256-bit-secret'</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">'/login'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> user = { <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">username</span>: <span class="string">'user'</span> };</span><br><span class="line">  <span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>({ <span class="attr">sub</span>: user.<span class="property">id</span>, <span class="attr">username</span>: user.<span class="property">username</span> }, secret, { <span class="attr">expiresIn</span>: <span class="string">'1h'</span> });</span><br><span class="line">  res.<span class="title function_">json</span>({ token });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/protected'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> token = req.<span class="property">headers</span>.<span class="property">authorization</span>.<span class="title function_">split</span>(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">const</span> decoded = jwt.<span class="title function_">verify</span>(token, secret);</span><br><span class="line">    res.<span class="title function_">json</span>({ <span class="attr">message</span>: <span class="string">'This is a protected route'</span>, <span class="attr">user</span>: decoded });</span><br><span class="line">  } <span class="keyword">catch</span> (err) {</span><br><span class="line">    res.<span class="title function_">status</span>(<span class="number">401</span>).<span class="title function_">json</span>({ <span class="attr">message</span>: <span class="string">'Invalid token'</span> });</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Server running on port 3000'</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>通过以上步骤和示例代码，可以实现 JWT 的生成和验证，从而确保客户端和服务器之间的通信安全且可靠。</p>
<h1 id="16-jwt的参数是什么样的，有什么意义？"><a href="#16-jwt的参数是什么样的，有什么意义？" class="headerlink" title="16.jwt的参数是什么样的，有什么意义？"></a>16.jwt的参数是什么样的，有什么意义？</h1><p>JWT (JSON Web Token) 是一种紧凑且自包含的方式，用于在各方之间以 JSON 对象的形式安全地传输信息。JWT 通常由三部分组成：Header、Payload 和 Signature。它们分别具有不同的意义和作用。</p>
<h3 id="1-Header"><a href="#1-Header" class="headerlink" title="1. Header"></a>1. Header</h3><p>Header 通常包含两部分：令牌类型（即 JWT）和所使用的签名算法（如 HMAC SHA256 或 RSA 等）。例如：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"alg"</span><span class="punctuation">:</span> <span class="string">"HS256"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"typ"</span><span class="punctuation">:</span> <span class="string">"JWT"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-Payload"><a href="#2-Payload" class="headerlink" title="2. Payload"></a>2. Payload</h3><p>Payload 是实际传输的数据。它包含声明（claims），即关于实体（通常是用户）和其他数据的陈述。声明有三种类型：</p>
<ul>
<li><p>**注册声明 (Registered Claims)**：预定义的声明，如 <code>iss</code> (签发者)、<code>exp</code> (过期时间)、<code>sub</code> (主题)、<code>aud</code> (受众) 等。尽管它们是可选的，但推荐在使用时遵循其规定的含义。</p>
</li>
<li><p>**公共声明 (Public Claims)**：可以自由定义的声明，但要避免与 JWT 规范中的注册声明冲突。通常使用 URI 或 URN 格式命名，以确保唯一性。</p>
</li>
<li><p>**私有声明 (Private Claims)**：自定义的声明，用于特定应用程序中的信息交换。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"admin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-Signature"><a href="#3-Signature" class="headerlink" title="3. Signature"></a>3. Signature</h3><p>签名是为了确保消息在传输过程中不被篡改。签名算法根据 Header 中指定的算法进行加密。通常，它将 Header 和 Payload 进行 Base64 编码，然后使用一个密钥（对于 HMAC 算法）或私钥（对于 RSA 或 ECDSA 算法）进行签名。其生成过程如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." + base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>

<p>生成的 JWT 形如：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></tbody></table></figure>

<p>其中，<code>xxxxx</code> 是 Header 的 Base64Url 编码，<code>yyyyy</code> 是 Payload 的 Base64Url 编码，<code>zzzzz</code> 是 Signature。</p>
<h3 id="JWT-的使用意义"><a href="#JWT-的使用意义" class="headerlink" title="JWT 的使用意义"></a>JWT 的使用意义</h3><ol>
<li><strong>安全传输信息</strong>：使用 JWT 可以确保信息在客户端和服务器之间的安全传输，防止信息被篡改。</li>
<li><strong>无状态的身份验证</strong>：服务器无需保存会话信息，只需验证 JWT，即可确认用户身份。</li>
<li>**跨域资源共享 (CORS)**：JWT 可以用于跨域资源请求的授权。</li>
</ol>
<p>JWT 广泛应用于身份验证、信息传输和分布式系统中，因其紧凑性和自包含性而备受青睐。</p>
<h1 id="17-密文密码能被存入负载中吗？为什么？"><a href="#17-密文密码能被存入负载中吗？为什么？" class="headerlink" title="17.密文密码能被存入负载中吗？为什么？"></a>17.密文密码能被存入负载中吗？为什么？</h1><p>在设计和使用 JWT (JSON Web Token) 时，将密文密码存入负载（Payload）中是不推荐的，原因如下：</p>
<h3 id="1-安全性风险"><a href="#1-安全性风险" class="headerlink" title="1. 安全性风险"></a>1. 安全性风险</h3><p>即使是加密的密码，也不应该存储在 JWT 的负载中。原因在于：</p>
<ul>
<li><strong>可解密风险</strong>：即使密码是加密的，如果攻击者获取到加密密钥或找到漏洞解密密文，他们就能得到原始密码。</li>
<li><strong>暴露敏感信息</strong>：JWT 通常在客户端和服务器之间传递。虽然负载被签名以防篡改，但内容并没有被加密。如果使用不安全的传输协议（如 HTTP 而非 HTTPS），攻击者可以截获 JWT 并访问其内容。</li>
</ul>
<h3 id="2-JWT-的设计目的"><a href="#2-JWT-的设计目的" class="headerlink" title="2. JWT 的设计目的"></a>2. JWT 的设计目的</h3><p>JWT 的设计目的是用于传递声明（如用户 ID、角色、权限等）而不是敏感信息。JWT 旨在提供一种紧凑、自包含的方式来验证用户身份和传递授权信息，而不是存储敏感数据。</p>
<h3 id="3-存储敏感信息的最佳实践"><a href="#3-存储敏感信息的最佳实践" class="headerlink" title="3. 存储敏感信息的最佳实践"></a>3. 存储敏感信息的最佳实践</h3><ul>
<li><strong>避免在 JWT 中存储敏感信息</strong>：应尽量避免在 JWT 的 Payload 中存储任何敏感信息，如密码、信用卡号等。</li>
<li><strong>使用 HTTPS</strong>：确保通过安全的传输层（HTTPS）来传递 JWT，防止中间人攻击。</li>
<li><strong>对敏感信息进行加密</strong>：如果确实需要传递敏感信息，应该对其进行加密，并在服务器端进行解密。</li>
<li><strong>短生命周期和刷新机制</strong>：确保 JWT 有短的有效期（例如 5-15 分钟），并使用刷新令牌来获取新的 JWT，减少被滥用的风险。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设你需要在 JWT 中传递某些敏感信息，正确的做法是：</p>
<ol>
<li><strong>加密敏感信息</strong>：使用安全的加密算法对敏感信息加密。</li>
<li><strong>使用自定义声明</strong>：在 Payload 中使用自定义声明来传递加密后的信息。</li>
<li><strong>验证机制</strong>：在服务器端解密并验证这些信息。</li>
</ol>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"admin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"encrypted_data"</span><span class="punctuation">:</span> <span class="string">"ENCRYPTED_PASSWORD_HERE"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>然而，即使如此，仍应尽量避免将加密后的密码放入 JWT 中，而是考虑其他安全的身份验证机制，如 OAuth2 的访问令牌和刷新令牌机制。</p>
<p>总之，出于安全考虑，不应在 JWT 的负载中存储密文密码。JWT 应主要用于传递身份和授权信息，任何敏感信息应通过加密并使用安全的传输协议来保护。</p>
<h1 id="18-payload中的信息会被解密吗？"><a href="#18-payload中的信息会被解密吗？" class="headerlink" title="18.payload中的信息会被解密吗？"></a>18.payload中的信息会被解密吗？</h1><p>JWT (JSON Web Token) 的 Payload 部分默认情况下是以明文形式存储的，这意味着它不会被加密。因此，Payload 中的信息不会被解密，因为它从一开始就没有被加密。以下是一些关键点解释这一点：</p>
<h3 id="1-Payload-是明文的"><a href="#1-Payload-是明文的" class="headerlink" title="1. Payload 是明文的"></a>1. Payload 是明文的</h3><p>JWT 的设计使得它的 Payload 部分是以 Base64Url 编码的形式存储的，而不是加密的。Base64Url 编码仅仅是编码，不是加密，所以任何能够获取到 JWT 的人都可以轻松地解码并读取其内容。</p>
<h3 id="2-签名保护篡改但不保护隐私"><a href="#2-签名保护篡改但不保护隐私" class="headerlink" title="2. 签名保护篡改但不保护隐私"></a>2. 签名保护篡改但不保护隐私</h3><p>JWT 的签名部分是用于验证 Token 的完整性和真实性。它确保了 Payload 和 Header 没有被篡改，但它并不加密 Payload。因此，虽然签名能防止数据被篡改，但不能防止数据被读取。</p>
<h3 id="3-如果需要加密，使用-JWE-JSON-Web-Encryption"><a href="#3-如果需要加密，使用-JWE-JSON-Web-Encryption" class="headerlink" title="3. 如果需要加密，使用 JWE (JSON Web Encryption)"></a>3. 如果需要加密，使用 JWE (JSON Web Encryption)</h3><p>如果你需要传输的内容包含敏感信息，应该使用 JWE 而不是普通的 JWT。JWE 允许对 Payload 进行加密，从而保护其内容的隐私。JWE 的结构如下：</p>
<ul>
<li><strong>Protected Header</strong>：包含加密算法的信息。</li>
<li><strong>Encrypted Key</strong>：加密的密钥。</li>
<li><strong>Initialization Vector</strong>：初始化向量，用于加密。</li>
<li><strong>Ciphertext</strong>：加密后的 Payload。</li>
<li><strong>Authentication Tag</strong>：用于验证加密内容的真实性。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>假设你有一个包含敏感信息的 JWT Payload，如下所示：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"admin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果你只是使用普通的 JWT，任何人都可以解码并看到这些信息：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></tbody></table></figure>

<h3 id="解码-Payload-示例"><a href="#解码-Payload-示例" class="headerlink" title="解码 Payload 示例"></a>解码 Payload 示例</h3><p>使用 Base64Url 解码工具，你可以解码上述 Token：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"sub"</span><span class="punctuation">:</span> <span class="string">"1234567890"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"John Doe"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"admin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="使用-JWE-加密-Payload"><a href="#使用-JWE-加密-Payload" class="headerlink" title="使用 JWE 加密 Payload"></a>使用 JWE 加密 Payload</h3><p>为了加密 Payload，应该使用 JWE，以下是简化的 JWE 结构：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"protected"</span><span class="punctuation">:</span> <span class="string">"eyJhbGciOiJSU0EtT0FFUCJ9"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"encrypted_key"</span><span class="punctuation">:</span> <span class="string">"Base64UrlEncodedEncryptedKey"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"iv"</span><span class="punctuation">:</span> <span class="string">"Base64UrlEncodedInitializationVector"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"ciphertext"</span><span class="punctuation">:</span> <span class="string">"Base64UrlEncodedCiphertext"</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"tag"</span><span class="punctuation">:</span> <span class="string">"Base64UrlEncodedAuthenticationTag"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>通过使用 JWE，Payload 会被加密，只有授权的一方才能解密并访问其内容。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>JWT 的 Payload 部分默认情况下不会被加密，因此信息是可见的。如果需要保护 Payload 中的信息隐私，应使用 JWE 来加密 Payload。这样可以确保只有具备正确解密密钥的授权方才能读取其中的内容。</p>
<h1 id="19-反向代理和正向代理的区别？"><a href="#19-反向代理和正向代理的区别？" class="headerlink" title="19.反向代理和正向代理的区别？"></a>19.反向代理和正向代理的区别？</h1><p>反向代理（Reverse Proxy）和正向代理（Forward Proxy）是两种不同类型的代理服务器，尽管它们都充当客户端和服务器之间的中介，但它们的用途和工作方式有显著的不同。</p>
<h3 id="1-正向代理（Forward-Proxy）"><a href="#1-正向代理（Forward-Proxy）" class="headerlink" title="1. 正向代理（Forward Proxy）"></a>1. 正向代理（Forward Proxy）</h3><p><strong>定义</strong>：<br>正向代理是一种代理服务器，位于客户端和原始服务器之间。它代表客户端向服务器发送请求，并将服务器的响应返回给客户端。</p>
<p><strong>工作方式</strong>：</p>
<ul>
<li>客户端（如浏览器）向正向代理服务器发送请求。</li>
<li>正向代理服务器接收请求并代表客户端将请求转发给目标服务器。</li>
<li>目标服务器将响应发送给正向代理服务器。</li>
<li>正向代理服务器将响应返回给客户端。</li>
</ul>
<p><strong>用途</strong>：</p>
<ul>
<li><strong>访问控制</strong>：通过正向代理，可以控制和过滤客户端的访问权限。例如，限制访问某些网站。</li>
<li><strong>缓存</strong>：正向代理可以缓存请求的资源，从而加速后续相同请求的处理速度。</li>
<li><strong>匿名性</strong>：隐藏客户端的 IP 地址，从而保护用户隐私。</li>
</ul>
<p><strong>示例</strong>：<br>客户端配置正向代理服务器，以访问被防火墙阻挡的网站。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 正向代理 -&gt; 目标服务器</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-反向代理（Reverse-Proxy）"><a href="#2-反向代理（Reverse-Proxy）" class="headerlink" title="2. 反向代理（Reverse Proxy）"></a>2. 反向代理（Reverse Proxy）</h3><p><strong>定义</strong>：<br>反向代理是一种代理服务器，位于服务器端，代表服务器接收客户端的请求，并将请求转发给后端服务器。客户端无需知道实际的后端服务器信息。</p>
<p><strong>工作方式</strong>：</p>
<ul>
<li>客户端向反向代理服务器发送请求。</li>
<li>反向代理服务器接收请求并根据负载均衡或其他策略将请求转发给适当的后端服务器。</li>
<li>后端服务器将响应发送给反向代理服务器。</li>
<li>反向代理服务器将响应返回给客户端。</li>
</ul>
<p><strong>用途</strong>：</p>
<ul>
<li><strong>负载均衡</strong>：将请求分配到多个后端服务器上，从而平衡负载，提高系统性能和可靠性。</li>
<li><strong>安全性</strong>：通过隐藏后端服务器的 IP 地址和结构，增强安全性。可以防护 DDoS 攻击。</li>
<li><strong>缓存</strong>：缓存静态内容，减少后端服务器的压力。</li>
<li><strong>SSL 卸载</strong>：处理 SSL 加密和解密，减轻后端服务器的负担。</li>
</ul>
<p><strong>示例</strong>：<br>客户端向反向代理服务器发送请求，反向代理服务器将请求分发给不同的后端服务器处理。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 -&gt; 反向代理 -&gt; 后端服务器群</span><br></pre></td></tr></tbody></table></figure>

<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><ul>
<li><p><strong>方向</strong>：</p>
<ul>
<li>正向代理：代理服务器在客户端一侧，代理客户端请求。</li>
<li>反向代理：代理服务器在服务器一侧，代理服务器响应。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>正向代理：主要用于访问控制、匿名性和缓存。</li>
<li>反向代理：主要用于负载均衡、安全性、缓存和 SSL 卸载。</li>
</ul>
</li>
<li><p><strong>隐私</strong>：</p>
<ul>
<li>正向代理：隐藏客户端信息。</li>
<li>反向代理：隐藏服务器信息。</li>
</ul>
</li>
</ul>
<h3 id="示例图解"><a href="#示例图解" class="headerlink" title="示例图解"></a>示例图解</h3><p><strong>正向代理</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[客户端] -&gt; [正向代理] -&gt; [目标服务器]</span><br></pre></td></tr></tbody></table></figure>

<p><strong>反向代理</strong>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[客户端] -&gt; [反向代理] -&gt; [后端服务器1]</span><br><span class="line">                                -&gt; [后端服务器2]</span><br><span class="line">                                -&gt; [后端服务器3]</span><br></pre></td></tr></tbody></table></figure>

<p>通过了解正向代理和反向代理的区别，可以根据具体需求选择合适的代理类型来优化网络访问和提高系统安全性。</p>
<h1 id="20-为什么要反向代理？"><a href="#20-为什么要反向代理？" class="headerlink" title="20.为什么要反向代理？"></a>20.为什么要反向代理？</h1><p>反向代理（Reverse Proxy）在现代网络架构中扮演着至关重要的角色，主要原因如下：</p>
<h3 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h3><p>反向代理服务器可以将客户端请求分发到多台后端服务器上，从而均衡负载。这不仅提高了系统的性能和响应速度，还增加了系统的可扩展性和可靠性。常用的负载均衡算法包括轮询、最小连接数和基于权重的分配等。</p>
<h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2. 安全性"></a>2. 安全性</h3><p>反向代理隐藏了后端服务器的实际 IP 地址和结构，增加了系统的安全性。它可以作为一个应用层防火墙，保护后端服务器免受直接攻击。反向代理还可以过滤恶意请求，阻止 DDoS 攻击，并实施 SSL 卸载，确保安全通信。</p>
<h3 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h3><p>反向代理可以缓存静态内容，如图像、视频、CSS 和 JavaScript 文件，从而减少后端服务器的负担，提高响应速度。通过缓存频繁访问的内容，可以显著降低服务器的处理压力和带宽消耗。</p>
<h3 id="4-SSL-卸载"><a href="#4-SSL-卸载" class="headerlink" title="4. SSL 卸载"></a>4. SSL 卸载</h3><p>SSL/TLS 加密和解密是计算密集型任务。反向代理可以处理 SSL/TLS 卸载，将加密和解密的负担从后端服务器移到反向代理服务器上，从而提高后端服务器的性能。</p>
<h3 id="5-动态网站加速"><a href="#5-动态网站加速" class="headerlink" title="5. 动态网站加速"></a>5. 动态网站加速</h3><p>反向代理可以通过缓存动态内容来加速动态网站的响应速度。某些反向代理服务器还支持内容压缩和优化，进一步提高页面加载速度。</p>
<h3 id="6-全球负载均衡"><a href="#6-全球负载均衡" class="headerlink" title="6. 全球负载均衡"></a>6. 全球负载均衡</h3><p>通过使用地理位置感知的反向代理，可以将客户端请求路由到距离最近的服务器，从而减少延迟，提升用户体验。这对于全球范围内有用户访问的网站尤为重要。</p>
<h3 id="7-简化架构管理"><a href="#7-简化架构管理" class="headerlink" title="7. 简化架构管理"></a>7. 简化架构管理</h3><p>反向代理可以集中管理多个后端服务器，简化了架构管理。它还可以进行协议转换，如将外部的 HTTP 请求转换为内部的 HTTPS 请求，或反之。</p>
<h3 id="8-高可用性和故障转移"><a href="#8-高可用性和故障转移" class="headerlink" title="8. 高可用性和故障转移"></a>8. 高可用性和故障转移</h3><p>反向代理可以检测后端服务器的健康状态，并将请求转发到可用的服务器上。如果某台后端服务器发生故障，反向代理可以自动将流量转移到其他可用的服务器上，确保服务的高可用性。</p>
<h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><ul>
<li>**内容分发网络 (CDN)**：CDN 服务商使用反向代理来缓存和分发内容到全球各地的节点，提高内容交付速度和可靠性。</li>
<li><strong>大型网站</strong>：如电商平台和社交媒体，通过反向代理实现负载均衡和缓存，以应对大量并发请求。</li>
<li><strong>企业内部网络</strong>：通过反向代理集中管理和保护内部应用系统，简化网络架构和安全管理。</li>
</ul>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>反向代理在现代网络架构中是一个强大的工具，通过提供负载均衡、安全性、缓存、SSL 卸载、动态网站加速、全球负载均衡、简化架构管理和高可用性等功能，帮助提高系统的性能、可靠性和安全性。无论是小型网站还是大型企业应用，反向代理都是不可或缺的组件。</p>
<h1 id="21-有自己部署过反向代理和负载均衡吗？"><a href="#21-有自己部署过反向代理和负载均衡吗？" class="headerlink" title="21.有自己部署过反向代理和负载均衡吗？"></a>21.有自己部署过反向代理和负载均衡吗？</h1><p>是的，我可以分享如何部署反向代理和负载均衡的经验。以下是关于部署反向代理和负载均衡的一些常见工具和步骤的详细说明。</p>
<h3 id="1-使用-Nginx-部署反向代理和负载均衡"><a href="#1-使用-Nginx-部署反向代理和负载均衡" class="headerlink" title="1. 使用 Nginx 部署反向代理和负载均衡"></a>1. 使用 Nginx 部署反向代理和负载均衡</h3><p>Nginx 是一个高性能的 HTTP 服务器和反向代理服务器，也可以用作负载均衡器。以下是基本步骤：</p>
<h4 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>在大多数 Linux 发行版上，可以通过包管理器安装 Nginx。例如，在 Ubuntu 上：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></tbody></table></figure>

<h4 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h4><p>假设你有一个后端服务器运行在 <code>http://backend_server</code>，可以配置 Nginx 将所有请求代理到该服务器。</p>
<p>编辑 Nginx 配置文件 <code>/etc/nginx/sites-available/default</code>：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / {</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>保存文件并重启 Nginx：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></tbody></table></figure>

<h4 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h4><p>假设有多个后端服务器 <code>http://backend1</code> 和 <code>http://backend2</code>，可以配置 Nginx 进行负载均衡。</p>
<p>编辑 Nginx 配置文件 <code>/etc/nginx/sites-available/default</code>：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend_servers {</span><br><span class="line">    <span class="attribute">server</span> backend1;</span><br><span class="line">    <span class="attribute">server</span> backend2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> your_domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / {</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend_servers;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>保存文件并重启 Nginx：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-使用-HAProxy-部署负载均衡"><a href="#2-使用-HAProxy-部署负载均衡" class="headerlink" title="2. 使用 HAProxy 部署负载均衡"></a>2. 使用 HAProxy 部署负载均衡</h3><p>HAProxy 是一个开源的高可用性负载均衡和代理服务器，支持 TCP 和 HTTP 应用。</p>
<h4 id="安装-HAProxy"><a href="#安装-HAProxy" class="headerlink" title="安装 HAProxy"></a>安装 HAProxy</h4><p>在大多数 Linux 发行版上，可以通过包管理器安装 HAProxy。例如，在 Ubuntu 上：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install haproxy</span><br></pre></td></tr></tbody></table></figure>

<h4 id="配置负载均衡-1"><a href="#配置负载均衡-1" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h4><p>编辑 HAProxy 配置文件 <code>/etc/haproxy/haproxy.cfg</code>：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log local0</span><br><span class="line">    log /dev/log local1 notice</span><br><span class="line">    chroot /var/lib/haproxy</span><br><span class="line">    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners</span><br><span class="line">    stats timeout 30s</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    mode http</span><br><span class="line">    option httplog</span><br><span class="line">    option dontlognull</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    timeout client  50000</span><br><span class="line">    timeout server  50000</span><br><span class="line">    errorfile 400 /etc/haproxy/errors/400.http</span><br><span class="line">    errorfile 403 /etc/haproxy/errors/403.http</span><br><span class="line">    errorfile 408 /etc/haproxy/errors/408.http</span><br><span class="line">    errorfile 500 /etc/haproxy/errors/500.http</span><br><span class="line">    errorfile 502 /etc/haproxy/errors/502.http</span><br><span class="line">    errorfile 503 /etc/haproxy/errors/503.http</span><br><span class="line">    errorfile 504 /etc/haproxy/errors/504.http</span><br><span class="line"></span><br><span class="line">frontend http_front</span><br><span class="line">    bind *:80</span><br><span class="line">    default_backend http_back</span><br><span class="line"></span><br><span class="line">backend http_back</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server backend1 backend1:80 check</span><br><span class="line">    server backend2 backend2:80 check</span><br></pre></td></tr></tbody></table></figure>

<p>保存文件并重启 HAProxy：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart haproxy</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-使用-AWS-Elastic-Load-Balancing-ELB"><a href="#3-使用-AWS-Elastic-Load-Balancing-ELB" class="headerlink" title="3. 使用 AWS Elastic Load Balancing (ELB)"></a>3. 使用 AWS Elastic Load Balancing (ELB)</h3><p>如果你使用 AWS 作为你的基础设施，可以使用 AWS 提供的 Elastic Load Balancing 服务，简化部署。</p>
<h4 id="创建一个负载均衡器"><a href="#创建一个负载均衡器" class="headerlink" title="创建一个负载均衡器"></a>创建一个负载均衡器</h4><ol>
<li>登录到 AWS 管理控制台。</li>
<li>导航到 EC2 服务。</li>
<li>在左侧导航栏中，点击“负载均衡器”。</li>
<li>点击“创建负载均衡器”，然后根据向导选择适合你的应用的负载均衡器类型（例如，应用负载均衡器）。</li>
<li>配置负载均衡器的详细信息，例如监听器、可用区和安全组。</li>
<li>配置目标组，添加你的后端实例到目标组。</li>
<li>完成配置并创建负载均衡器。</li>
</ol>
<p>通过这些步骤和工具，你可以成功部署反向代理和负载均衡，增强系统的性能、安全性和可扩展性。每个工具都有其独特的优势，可以根据你的具体需求选择最合适的解决方案。</p>
<h1 id="22-Web-socket的作用，怎么实现的？"><a href="#22-Web-socket的作用，怎么实现的？" class="headerlink" title="22.Web socket的作用，怎么实现的？"></a>22.Web socket的作用，怎么实现的？</h1><h3 id="WebSocket的作用"><a href="#WebSocket的作用" class="headerlink" title="WebSocket的作用"></a>WebSocket的作用</h3><p>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与传统的 HTTP 请求-响应模式不同，WebSocket 允许服务器主动向客户端发送数据，而无需客户端每次都发起请求。它适用于实时应用程序，如聊天应用、实时通知、在线游戏、协作工具和股票行情等。</p>
<h3 id="WebSocket的实现"><a href="#WebSocket的实现" class="headerlink" title="WebSocket的实现"></a>WebSocket的实现</h3><h4 id="1-客户端实现"><a href="#1-客户端实现" class="headerlink" title="1. 客户端实现"></a>1. 客户端实现</h4><p>在客户端，通常使用 JavaScript 和浏览器提供的 WebSocket API 来实现 WebSocket 连接。以下是一个简单的示例：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">'ws://example.com/socket'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功时调用</span></span><br><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'WebSocket is open now.'</span>);</span><br><span class="line">    <span class="comment">// 向服务器发送一条消息</span></span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">'Hello Server!'</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到消息时调用</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Message from server '</span>, event.<span class="property">data</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接关闭时调用</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'WebSocket is closed now.'</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生错误时调用</span></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">error</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'WebSocket error: '</span>, error);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-服务器端实现"><a href="#2-服务器端实现" class="headerlink" title="2. 服务器端实现"></a>2. 服务器端实现</h4><p>服务器端实现 WebSocket 通常需要一个支持 WebSocket 协议的服务器框架。以下是使用 Node.js 和 <code>ws</code> 库实现的示例：</p>
<p>首先，安装 <code>ws</code> 库：</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ws</span><br></pre></td></tr></tbody></table></figure>

<p>然后，创建一个 WebSocket 服务器：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 WebSocket 服务器，监听指定的端口</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>({ <span class="attr">port</span>: <span class="number">8080</span> });</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">'connection'</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'A new client connected'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收到消息时调用</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">'message'</span>, <span class="keyword">function</span> <span class="title function_">incoming</span>(<span class="params">message</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'received: %s'</span>, message);</span><br><span class="line">        <span class="comment">// 向客户端发送消息</span></span><br><span class="line">        ws.<span class="title function_">send</span>(<span class="string">`Hello, you sent -&gt; <span class="subst">${message}</span>`</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接关闭时调用</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">'close'</span>, <span class="keyword">function</span> <span class="title function_">close</span>(<span class="params"></span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Client disconnected'</span>);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生错误时调用</span></span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">'error'</span>, <span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">err</span>) {</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Error: '</span>, err);</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'WebSocket server is listening on ws://localhost:8080'</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="WebSocket的工作流程"><a href="#WebSocket的工作流程" class="headerlink" title="WebSocket的工作流程"></a>WebSocket的工作流程</h3><ol>
<li><p><strong>握手阶段</strong>：</p>
<ul>
<li>客户端发起一个 HTTP 请求以升级到 WebSocket 协议。</li>
<li>服务器响应请求并确认协议升级。</li>
<li>一旦握手成功，连接将从 HTTP 协议升级到 WebSocket 协议。</li>
</ul>
</li>
<li><p><strong>数据传输阶段</strong>：</p>
<ul>
<li>客户端和服务器之间可以通过打开的 WebSocket 连接相互发送文本或二进制数据帧。</li>
<li>这种全双工通信允许实时、低延迟的数据交换。</li>
</ul>
</li>
<li><p><strong>连接关闭</strong>：</p>
<ul>
<li>任何一方（客户端或服务器）都可以关闭 WebSocket 连接。</li>
<li>连接关闭时，双方都会收到通知，进行必要的清理操作。</li>
</ul>
</li>
</ol>
<h3 id="WebSocket的优势"><a href="#WebSocket的优势" class="headerlink" title="WebSocket的优势"></a>WebSocket的优势</h3><ul>
<li><strong>低延迟</strong>：相比传统的 HTTP 请求-响应模式，WebSocket 减少了网络延迟，因为它避免了频繁的连接建立和断开。</li>
<li><strong>双向通信</strong>：允许服务器主动发送数据到客户端，而不仅仅是响应客户端请求。</li>
<li><strong>节省带宽</strong>：通过保持一个持久连接，减少了 HTTP 请求头的开销。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>实时聊天应用</strong>：例如，Slack、WhatsApp Web 版。</li>
<li><strong>实时通知</strong>：如实时推送的社交媒体通知。</li>
<li><strong>在线协作工具</strong>：如 Google Docs 的实时编辑功能。</li>
<li><strong>实时游戏</strong>：如多人在线游戏的状态同步。</li>
<li><strong>金融数据</strong>：如股票行情的实时更新。</li>
</ul>
<p>通过了解和实现 WebSocket，可以构建高效、实时的应用程序，从而提升用户体验。</p>
<img src="/2024/05/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/MyBlogs/source/_posts/苍穹外卖面试问题总结/image-20240518132939689.png" alt="image-20240518132939689" style="zoom:200%;">
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">程玉春</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://cyc199811.github.io/2024/05/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">https://cyc199811.github.io/2024/05/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">程玉春</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2024/05/18/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            程玉春
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/05/14/day28/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="day022">
                        
                        <span class="card-title">day022</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-05-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/" class="post-category">
                                    代码随想录每日刷题
                                </a>
                            
                            <a href="/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="post-category">
                                    回溯算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">回溯算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="330695641"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <span id="year">2023</span>
            <a href="/about" target="_blank">程玉春</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">36.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/CYC199811/CYC199811.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:yuchuncheng915@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1635194004" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1635194004" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>




    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

      <!-- 后面添加的樱花效果 -->
    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/source/js/sakura.js"><\/script>');
        }
    </script> 

</body>

</html>
