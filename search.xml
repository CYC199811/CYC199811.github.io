<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>day012</title>
      <link href="/2024/05/04/day15/"/>
      <url>/2024/05/04/day15/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的统一迭代法："><a href="#二叉树的统一迭代法：" class="headerlink" title="二叉树的统一迭代法："></a>二叉树的统一迭代法：</h1><h2 id="思路：利用栈的先进后出规则，并添加-null-值进行遍历"><a href="#思路：利用栈的先进后出规则，并添加-null-值进行遍历" class="headerlink" title="思路：利用栈的先进后出规则，并添加 null 值进行遍历"></a>思路：利用栈的先进后出规则，并添加 null 值进行遍历</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Tree1 {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 前序遍历顺序：中-左-右，入栈顺序：右-左-中</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">            stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            //节点的入栈顺序和遍历的完全相反</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">                stack.push(node);</span><br><span class="line"></span><br><span class="line">                stack.push(null);// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();//将空节点弹出栈</span><br><span class="line">                node = stack.peek();//重新取出栈中元素</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);//收集结果</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 中序遍历顺序: 左-中-右 入栈顺序： 右-中-左</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">        stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(null);</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 后序遍历顺序 左-右-中 入栈顺序：中-右-左</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">            stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(null);</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二叉树的层序遍历："><a href="#二叉树的层序遍历：" class="headerlink" title="二叉树的层序遍历："></a>二叉树的层序遍历：</h1><h2 id="思路：类似前序遍历，但要每层进行结果收集"><a href="#思路：类似前序遍历，但要每层进行结果收集" class="headerlink" title="思路：类似前序遍历，但要每层进行结果收集"></a>思路：类似前序遍历，但要每层进行结果收集</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class TreeLevelOrder {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //DFS--递归方式</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) {</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) {</span><br><span class="line">            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        }</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //BFS--迭代方式--借助队列</span><br><span class="line">    public void checkFun02(TreeNode node) {</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) {</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day011</title>
      <link href="/2024/05/03/day14/"/>
      <url>/2024/05/03/day14/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的递归遍历："><a href="#二叉树的递归遍历：" class="headerlink" title="二叉树的递归遍历："></a>二叉树的递归遍历：</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Tree {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public void preorder(TreeNode root, List&lt;Integer&gt; result){</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    }</span><br><span class="line">    //中序遍历</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    private void inorder(TreeNode root, List&lt;Integer&gt; result) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        inorder(root.left, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorder(root.right, result);</span><br><span class="line">    }</span><br><span class="line">    //后序遍历</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    private void postorder(TreeNode root, List&lt;Integer&gt; result) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        inorder(root.left, result);</span><br><span class="line">        inorder(root.right, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的迭代遍历："><a href="#二叉树的迭代遍历：" class="headerlink" title="二叉树的迭代遍历："></a>二叉树的迭代遍历：</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Tree {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while ( !stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null){</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">            if (node.left != null){</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty()){</span><br><span class="line">            if (cur != null){</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            }else{</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null) {</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) {</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null) {</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            }</span><br><span class="line">            if (node.right != null) {</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2024/05/03/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2024/05/03/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>#柱状图中最大的矩形：LK084</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package org.example.单调栈;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class LK084 {</span><br><span class="line">    public int largestRectangleArea3(int[] heights) {</span><br><span class="line"></span><br><span class="line">        int[] newHeight = new int[heights.length + 2];</span><br><span class="line">        System.arraycopy(heights, 0, newHeight, 1, heights.length);</span><br><span class="line">        newHeight[heights.length+1] = 0;</span><br><span class="line">        newHeight[0] = 0;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(0);</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; newHeight.length; i++) {</span><br><span class="line">            while (newHeight[i] &lt; newHeight[stack.peek()]) {</span><br><span class="line">                int mid = stack.pop();</span><br><span class="line">                int w = i - stack.peek() - 1;</span><br><span class="line">                int h = newHeight[mid];</span><br><span class="line">                res = Math.max(res, w * h);</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line">    int largestRectangleArea2(int[] heights) {</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        // 数组扩容，在头和尾各加入一个元素</span><br><span class="line">        int [] newHeights = new int[heights.length + 2];</span><br><span class="line">        newHeights[0] = 0;</span><br><span class="line">        newHeights[newHeights.length - 1] = 0;</span><br><span class="line">        for (int index = 0; index &lt; heights.length; index++){</span><br><span class="line">            newHeights[index + 1] = heights[index];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        st.push(0);</span><br><span class="line">        int result = 0;</span><br><span class="line">        // 第一个元素已经入栈，从下标1开始</span><br><span class="line">        for (int i = 1; i &lt; heights.length; i++) {</span><br><span class="line">            // 注意heights[i] 是和heights[st.top()] 比较 ，st.top()是下标</span><br><span class="line">            if (heights[i] &gt; heights[st.peek()]) {</span><br><span class="line">                st.push(i);</span><br><span class="line">            } else if (heights[i] == heights[st.peek()]) {</span><br><span class="line">                st.pop(); // 这个可以加，可以不加，效果一样，思路不同</span><br><span class="line">                st.push(i);</span><br><span class="line">            } else {</span><br><span class="line">                while (heights[i] &lt; heights[st.peek()]) { // 注意是while</span><br><span class="line">                    int mid = st.peek();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    int left = st.peek();</span><br><span class="line">                    int right = i;</span><br><span class="line">                    int w = right - left - 1;</span><br><span class="line">                    int h = heights[mid];</span><br><span class="line">                    result = Math.max(result, w * h);</span><br><span class="line">                }</span><br><span class="line">                st.push(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public int largestRectangleArea(int[] heights) {</span><br><span class="line">        int length = heights.length;</span><br><span class="line">        int[] minLeftIndex = new int [length];</span><br><span class="line">        int[] minRightIndex = new int [length];</span><br><span class="line">        // 记录左边第一个小于该柱子的下标</span><br><span class="line">        minLeftIndex[0] = -1 ;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) {</span><br><span class="line">            int t = i - 1;</span><br><span class="line">            // 这里不是用if，而是不断向右寻找的过程</span><br><span class="line">            while (t &gt;= 0 &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];</span><br><span class="line">            minLeftIndex[i] = t;</span><br><span class="line">        }</span><br><span class="line">        // 记录每个柱子右边第一个小于该柱子的下标</span><br><span class="line">        minRightIndex[length - 1] = length;</span><br><span class="line">        for (int i = length - 2; i &gt;= 0; i--) {</span><br><span class="line">            int t = i + 1;</span><br><span class="line">            while(t &lt; length &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];</span><br><span class="line">            minRightIndex[i] = t;</span><br><span class="line">        }</span><br><span class="line">        // 求和</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++) {</span><br><span class="line">            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);</span><br><span class="line">            result = Math.max(sum, result);</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] heights = {2,4};</span><br><span class="line">        LK084 lk084 = new LK084();</span><br><span class="line">        int size = lk084.largestRectangleArea(heights);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day09</title>
      <link href="/2024/05/02/day13/"/>
      <url>/2024/05/02/day13/</url>
      
        <content type="html"><![CDATA[<h2 id="滑动窗口：LK239"><a href="#滑动窗口：LK239" class="headerlink" title="滑动窗口：LK239"></a>滑动窗口：LK239</h2><h3 id="思路：单调栈，保持队列内的元素单调增！获取队列口元素！"><a href="#思路：单调栈，保持队列内的元素单调增！获取队列口元素！" class="headerlink" title="思路：单调栈，保持队列内的元素单调增！获取队列口元素！"></a>思路：单调栈，保持队列内的元素单调增！获取队列口元素！</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayDeque;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num239 {</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) {</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] res = new int[n - k + 1];</span><br><span class="line">        int idx = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) {</span><br><span class="line">            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br><span class="line">            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){</span><br><span class="line">                deque.poll();</span><br><span class="line">            }</span><br><span class="line">            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) {</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br><span class="line">            if(i &gt;= k - 1){</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] nums = {1, -1};</span><br><span class="line">        num239 num239 = new num239();</span><br><span class="line">        int[] res = num239.maxSlidingWindow(nums, 1);</span><br><span class="line">        for (int re : res) {</span><br><span class="line">            System.out.println(re);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="前K个高频元素：LK347"><a href="#前K个高频元素：LK347" class="headerlink" title="前K个高频元素：LK347"></a>前K个高频元素：LK347</h2><h3 id="思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！"><a href="#思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！" class="headerlink" title="思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！"></a>思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！</h3><h3 id="小顶堆就是一个二叉树"><a href="#小顶堆就是一个二叉树" class="headerlink" title="小顶堆就是一个二叉树"></a>小顶堆就是一个二叉树</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int[] topKFrequent2(int[] nums, int k) {</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数</span><br><span class="line">    for (int num : nums) {</span><br><span class="line">        map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">    }</span><br><span class="line">    //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span><br><span class="line">    //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span><br><span class="line">    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);</span><br><span class="line">    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { //小顶堆只需要维持k个元素有序</span><br><span class="line">        if (pq.size() &lt; k) { //小顶堆元素个数小于k个时直接加</span><br><span class="line">            pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br><span class="line">        } else {</span><br><span class="line">            if (entry.getValue() &gt; pq.peek()[1]) { //当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span><br><span class="line">                pq.poll(); //弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span><br><span class="line">                pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int[] ans = new int[k];</span><br><span class="line">    for (int i = k - 1; i &gt;= 0; i--) { //依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span><br><span class="line">        ans[i] = pq.poll()[0];</span><br><span class="line">    }</span><br><span class="line">    return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
            <tag> 优先级队列 </tag>
            
            <tag> 小顶堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day08</title>
      <link href="/2024/04/27/day11/"/>
      <url>/2024/04/27/day11/</url>
      
        <content type="html"><![CDATA[<h2 id="有效的括号：LK020😂"><a href="#有效的括号：LK020😂" class="headerlink" title="有效的括号：LK020😂"></a>有效的括号：LK020😂</h2><h3 id="思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！"><a href="#思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！" class="headerlink" title="思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！"></a>思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num020 {</span><br><span class="line">    public boolean isValid(String s) {</span><br><span class="line">        //括号只能成对</span><br><span class="line">        if (s.length() % 2 != 0 || s.length() == 0) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;Character&gt; stackChars = new Stack&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            if (ch == '(') {</span><br><span class="line">                stackChars.push(')');</span><br><span class="line">            } else if (ch == '[') {</span><br><span class="line">                stackChars.push(']');</span><br><span class="line">            } else if (ch == '{') {</span><br><span class="line">                stackChars.push('}');</span><br><span class="line">            } else if (stackChars.isEmpty() || stackChars.peek() != ch) {</span><br><span class="line">                return false;</span><br><span class="line">            } else {</span><br><span class="line">                stackChars.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return stackChars.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String s1 = "()[]{}";</span><br><span class="line">       // String s2 = "()}";</span><br><span class="line">        //String s3 = "([]}";</span><br><span class="line">        num020 num020 = new num020();</span><br><span class="line">        boolean s11 = num020.isValid(s1);</span><br><span class="line">        System.out.println(s11);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除字符串中的所有相邻重复项-LK1047"><a href="#删除字符串中的所有相邻重复项-LK1047" class="headerlink" title="删除字符串中的所有相邻重复项: LK1047"></a>删除字符串中的所有相邻重复项: LK1047</h2><h3 id="思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！"><a href="#思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！" class="headerlink" title="思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！"></a>思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num1047 {</span><br><span class="line">    public String removeDuplicates(String s) {</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">            if (stack.isEmpty()){</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            }else {</span><br><span class="line">                if (s.charAt(i) != stack.peek()){</span><br><span class="line">                    stack.push(s.charAt(i));</span><br><span class="line">                }else {</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        int lenth = stack.size();</span><br><span class="line">        char[] sresult = new char[lenth];</span><br><span class="line">        while (! stack.isEmpty()){</span><br><span class="line">            sresult[lenth - 1] = stack.pop();</span><br><span class="line">            lenth --;</span><br><span class="line">        }</span><br><span class="line">        String result = new String(sresult);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="逆波兰表达式：LK150"><a href="#逆波兰表达式：LK150" class="headerlink" title="逆波兰表达式：LK150"></a>逆波兰表达式：LK150</h2><h3 id="思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！"><a href="#思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！" class="headerlink" title="思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！"></a>思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！</h3><h3 id="注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：-a-b-a先入栈后出栈-，所以是：-a-b"><a href="#注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：-a-b-a先入栈后出栈-，所以是：-a-b" class="headerlink" title="注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：[a, b, /] a先入栈后出栈 ，所以是：  a / b"></a>注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：[a, b, /] a先入栈后出栈 ，所以是：  a / b</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈与队列;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LK150 {</span><br><span class="line">    public int evalRPN(String[] tokens) {</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        for (String t : tokens) {</span><br><span class="line">        switch (t){</span><br><span class="line">            case "+" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b+a);</span><br><span class="line">            }</span><br><span class="line">            case "-" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b-a);</span><br><span class="line">            }</span><br><span class="line">            case "*" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b*a);</span><br><span class="line">            }</span><br><span class="line">            case "/" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b/a);</span><br><span class="line">            }</span><br><span class="line">            default -&gt; {        //数字</span><br><span class="line">                stack.push(Integer.parseInt(t));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        return stack.pop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用栈实现队列</title>
      <link href="/2024/04/26/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2024/04/26/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用栈实现队列："><a href="#用栈实现队列：" class="headerlink" title="用栈实现队列："></a>用栈实现队列：</h2><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2" style="zoom:200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class MyQueue {</span><br><span class="line">    Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    public MyQueue() {</span><br><span class="line">        Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void push(int x) {</span><br><span class="line">        while (!outStack.isEmpty()){</span><br><span class="line">            inStack.push(outStack.pop());</span><br><span class="line">        }</span><br><span class="line">        outStack.push(x);</span><br><span class="line">        while (!inStack.isEmpty()){</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int pop()  {</span><br><span class="line">       int pop =  outStack.pop();</span><br><span class="line">        return pop;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int peek() {</span><br><span class="line">        int peek =  inStack.peek();</span><br><span class="line">        return peek;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean empty() {</span><br><span class="line">        return inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用队列实现栈</title>
      <link href="/2024/04/26/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>/2024/04/26/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="用队列实现栈："><a href="#用队列实现栈：" class="headerlink" title="用队列实现栈："></a>用队列实现栈：</h2><img src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈" style="zoom: 200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    <span class="comment">//q1作为主要的队列，其元素排列顺序和出栈顺序相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//q2仅作为临时放置</span></span><br><span class="line">    Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//在加入元素时先将q1中的元素依次出栈压入q2，然后将新加入的元素压入q1，再将q2中的元素依次出栈压入q1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        }</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span> (q2.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">//移动除了 A 的其它数</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>)</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.add(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        queue.add(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基本数据结构的实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/2024/04/25/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/25/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="例：aab"><a href="#例：aab" class="headerlink" title="例：aab"></a>例：aab</h2><h2 id="前缀：a-aa-要包含首字母，不包含尾字母"><a href="#前缀：a-aa-要包含首字母，不包含尾字母" class="headerlink" title="前缀：a,aa(要包含首字母，不包含尾字母)"></a>前缀：a,aa(要包含首字母，不包含尾字母)</h2><h2 id="后缀：b-ab（要包含尾字母，不包含首字母）"><a href="#后缀：b-ab（要包含尾字母，不包含首字母）" class="headerlink" title="后缀：b,ab（要包含尾字母，不包含首字母）"></a>后缀：b,ab（要包含尾字母，不包含首字母）</h2><h2 id="最长的前缀：aa"><a href="#最长的前缀：aa" class="headerlink" title="最长的前缀：aa"></a>最长的前缀：aa</h2><h2 id="最长的后缀：ab"><a href="#最长的后缀：ab" class="headerlink" title="最长的后缀：ab"></a>最长的后缀：ab</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="next数组就是一个前缀表（prefix-table）"><a href="#next数组就是一个前缀表（prefix-table）" class="headerlink" title="next数组就是一个前缀表（prefix table）"></a>next数组就是一个前缀表（prefix table）</h2><h3 id="KMP是根据模式串来获取next-数组的！！"><a href="#KMP是根据模式串来获取next-数组的！！" class="headerlink" title="KMP是根据模式串来获取next[ ] 数组的！！"></a>KMP是根据模式串来获取next[ ] 数组的！！</h3><h3 id="前缀表有什么作用呢？"><a href="#前缀表有什么作用呢？" class="headerlink" title="前缀表有什么作用呢？"></a>前缀表有什么作用呢？</h3><h3 id="前缀表是用来回退的，它记录了模式串与主串-文本串-不匹配的时候，模式串应该从哪里开始重新匹配。"><a href="#前缀表是用来回退的，它记录了模式串与主串-文本串-不匹配的时候，模式串应该从哪里开始重新匹配。" class="headerlink" title="前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。"></a><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></h3><p>sss<img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif" alt="KMP详解1" style="zoom: 200%;"></p><h2 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h2><h3 id="文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。"><a href="#文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。" class="headerlink" title="文章中字符串的前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。"></a>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</h3><h3 id="后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。"><a href="#后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。" class="headerlink" title="后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。"></a><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</h3><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif" alt="KMP精讲2" style="zoom:150%;"><h2 id="以下我们以前缀表统一减一之后的next数组来做演示。"><a href="#以下我们以前缀表统一减一之后的next数组来做演示。" class="headerlink" title="以下我们以前缀表统一减一之后的next数组来做演示。"></a><strong>以下我们以前缀表统一减一之后的next数组来做演示</strong>。</h2><h3 id="有了next数组，就可以根据next数组来-匹配文本串s，和模式串t了。"><a href="#有了next数组，就可以根据next数组来-匹配文本串s，和模式串t了。" class="headerlink" title="有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。"></a>有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。</h3><h3 id="注意next数组是新前缀表（旧前缀表统一减一了）。"><a href="#注意next数组是新前缀表（旧前缀表统一减一了）。" class="headerlink" title="注意next数组是新前缀表（旧前缀表统一减一了）。"></a>注意next数组是新前缀表（旧前缀表统一减一了）。</h3><h3 id="匹配过程动画如下："><a href="#匹配过程动画如下：" class="headerlink" title="匹配过程动画如下："></a>匹配过程动画如下：</h3><img src="https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif" alt="KMP精讲4" style="zoom: 150%;"><h2 id="找出字符串中第一个匹配项的下标-LK028"><a href="#找出字符串中第一个匹配项的下标-LK028" class="headerlink" title="找出字符串中第一个匹配项的下标:LK028"></a>找出字符串中第一个匹配项的下标:LK028</h2><h3 id="通过模式串的前缀表即next数组来匹配文本串！！"><a href="#通过模式串的前缀表即next数组来匹配文本串！！" class="headerlink" title="通过模式串的前缀表即next数组来匹配文本串！！"></a>通过模式串的前缀表即next数组来匹配文本串！！</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package org.example.技巧.KMP算法;</span><br><span class="line"></span><br><span class="line">public class num028 {</span><br><span class="line">    public int strStr(String haystack, String needle) {</span><br><span class="line">        // 如果needle的长度为0，则返回0</span><br><span class="line">        if (needle.length() == 0) return 0;</span><br><span class="line">        // 创建一个next数组，用于存储needle的最长公共前缀和后缀的长度</span><br><span class="line">        int[] next = new int[needle.length()];</span><br><span class="line">        // 调用getNext方法，计算next数组</span><br><span class="line">        getNext(next, needle);</span><br><span class="line"></span><br><span class="line">        // 初始化j为0</span><br><span class="line">        int j = 0;</span><br><span class="line">        // 遍历haystack</span><br><span class="line">        for (int i = 0; i &lt; haystack.length(); i++) {</span><br><span class="line">            // 如果j大于0，且needle的j位置的字符不等于haystack的i位置的字符，则将j置为next[j-1]</span><br><span class="line">            while (j &gt; 0 &amp;&amp; needle.charAt(j) != haystack.charAt(i))</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            // 如果needle的j位置的字符等于haystack的i位置的字符，则j加1</span><br><span class="line">            if (needle.charAt(j) == haystack.charAt(i))</span><br><span class="line">                j++;</span><br><span class="line">            // 如果j等于needle的长度，则说明找到了needle，返回i-needle.length()+1</span><br><span class="line">            if (j == needle.length())</span><br><span class="line">                return i - needle.length() + 1;</span><br><span class="line">        }</span><br><span class="line">        // 如果没有找到needle，则返回-1</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void getNext(int[] next, String s) {</span><br><span class="line">        // 初始化j为0</span><br><span class="line">        int j = 0;</span><br><span class="line">        // 将next[0]置为0</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        // 遍历s</span><br><span class="line">        for (int i = 1; i &lt; s.length(); i++) {</span><br><span class="line">            // 如果j大于0，且s的j位置的字符不等于s的i位置的字符，则将j置为next[j-1]</span><br><span class="line">            while (j &gt; 0 &amp;&amp; s.charAt(j) != s.charAt(i))</span><br><span class="line">                j = next[j - 1];</span><br><span class="line">            // 如果s的j位置的字符等于s的i位置的字符，则j加1</span><br><span class="line">            if (s.charAt(j) == s.charAt(i))</span><br><span class="line">                j++;</span><br><span class="line">            // 将next[i]置为j</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="重复的子字符串-LK459"><a href="#重复的子字符串-LK459" class="headerlink" title="重复的子字符串:LK459"></a>重复的子字符串:LK459</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.example.技巧.KMP算法;</span><br><span class="line"></span><br><span class="line">public class num459 {</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) {</span><br><span class="line">        //KMP算法</span><br><span class="line">        if (s.equals(""))return false;</span><br><span class="line">        int length = s.length();</span><br><span class="line">        char[] chars = s.toCharArray();</span><br><span class="line">        //初始化</span><br><span class="line">        int j = 0;</span><br><span class="line">        int[] next = new int[length];</span><br><span class="line">        next[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) {</span><br><span class="line">            //不相同</span><br><span class="line">            while (j &gt; 0 &amp;&amp; chars[i] != chars[j]){j = next[j - 1];}</span><br><span class="line">            //相同</span><br><span class="line">            if (chars[i] == chars[j]){j ++;}</span><br><span class="line">            //更新</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        if (next[length - 1] &gt; 0 &amp;&amp; length % (length - next[length - 1]) == 0){</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> KMP算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/04/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85/"/>
      <url>/2024/04/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="分割等和子集：LeetCode416"><a href="#分割等和子集：LeetCode416" class="headerlink" title="分割等和子集：LeetCode416"></a>分割等和子集：LeetCode416</h2><h3 id="首先，本题要求集合里能否出现总和为-sum-2-的子集。"><a href="#首先，本题要求集合里能否出现总和为-sum-2-的子集。" class="headerlink" title="首先，本题要求集合里能否出现总和为 sum / 2 的子集。"></a>首先，本题要求集合里能否出现总和为 sum / 2 的子集。</h3><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><h3 id="滚动数组法："><a href="#滚动数组法：" class="headerlink" title="滚动数组法："></a>滚动数组法：</h3><p>1.定义一个 dp[] 数组</p><p>2.dp[j]：表示容量为 j 的背包可以最大装下的值</p><p>3.确定遍历顺序</p><p>4.确定递归条件 dp[j] = max(dp[j], dp[j- weight[i]] + value[i] )</p><img src="/2024/04/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E8%83%8C%E5%8C%85/chengyuchun/Desktop/Blogs/source/imgs/image-20240424211005472.jpg" alt="image-20240424211005472" style="zoom:150%;"><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK416 {</span><br><span class="line">    public boolean canPartition(int[] nums) {</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        }</span><br><span class="line">        if (sum % 2 == 1){</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        //定义dp[]数组</span><br><span class="line">        int[] dp = new int[target + 1];</span><br><span class="line">        //初始化数组</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        //确定遍历顺序</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) {//物品 物品 i 的重量是 nums[i]，其价值也是 nums[i]</span><br><span class="line">            for (int j = target; j &gt;= nums[i]; j --){//背包  j &gt;= nums[i]背包的容量要大于物品的重量</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i] );</span><br><span class="line">            }</span><br><span class="line">            //如果找到了可以去掉不必要的遍历</span><br><span class="line">            if (dp[target] == target){</span><br><span class="line">                return true;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return dp[target] == target;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二维数组法："><a href="#二维数组法：" class="headerlink" title="二维数组法："></a>二维数组法：</h3><h3 id="首先，本题要求集合里能否出现总和为-sum-2-的子集。-1"><a href="#首先，本题要求集合里能否出现总和为-sum-2-的子集。-1" class="headerlink" title="首先，本题要求集合里能否出现总和为 sum / 2 的子集。"></a>首先，本题要求集合里能否出现总和为 sum / 2 的子集。</h3><ul><li>背包的体积为sum / 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><h3 id="滚动数组法：-1"><a href="#滚动数组法：-1" class="headerlink" title="滚动数组法："></a>滚动数组法：</h3><p>1.定义一个 dp[][] 数组</p><p>2.dp[i][j]：表示容量为 j 的背包可以最大装下的值</p><p>3.确定遍历顺序</p><p>4.确定递归条件 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK416_2 {</span><br><span class="line">    public boolean canPartition(int[] nums) {</span><br><span class="line">        //using 2-D DP array.</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        //check edge cases;</span><br><span class="line">        if(len == 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        //we only deal with even numbers. If sum is odd, return false;</span><br><span class="line">        if(sum % 2 == 1)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        int[][] dp = new int[nums.length][target + 1];</span><br><span class="line">        </span><br><span class="line">        //initialize dp array</span><br><span class="line">        for(int j = nums[0]; j &lt;= target; j++){</span><br><span class="line">            dp[0][j] = nums[0];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt; len; i++){</span><br><span class="line">            for(int j = 0; j &lt;= target; j++){</span><br><span class="line">                if (j &lt; nums[i])</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                else</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return dp[len - 1][target] == target;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中滚动数组他的背包遍历只能从后往前遍历</p>]]></content>
      
      
      <categories>
          
          <category> 动态规划书包问题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day07</title>
      <link href="/2024/04/24/day07/"/>
      <url>/2024/04/24/day07/</url>
      
        <content type="html"><![CDATA[<h2 id="反转字符串：LK334"><a href="#反转字符串：LK334" class="headerlink" title="反转字符串：LK334"></a>反转字符串：LK334</h2><p>双指针法：一个在左边，一个在右边，进行值的交换</p><img src="https://code-thinking.cdn.bcebos.com/gifs/344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.gif" alt="344.反转字符串" style="zoom: 150%;"><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">public class num344 {</span><br><span class="line">    public void reverseString(char[] s) {</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = s.length - 1;</span><br><span class="line">        while (left &lt; right){</span><br><span class="line">            char leftChar = s[left];</span><br><span class="line">            char rightChar = s[right];</span><br><span class="line">            s[left] = rightChar;</span><br><span class="line">            s[right] = leftChar;</span><br><span class="line">            left ++;</span><br><span class="line">            right --;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="反转字符串-II：LK541"><a href="#反转字符串-II：LK541" class="headerlink" title="反转字符串 II：LK541"></a>反转字符串 II：LK541</h2><p>和翻转字符串 1 一样，只是这里的反转的组变成了 2 * K ，然后在 2 * K 中进行上述的操作！！！</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">public class num541 {</span><br><span class="line">    public String reverseStr(String s, int k) {</span><br><span class="line">        char[] ch = s.toCharArray();//转换成数组</span><br><span class="line">        for(int i = 0; i &lt; ch.length; i += 2 * k){</span><br><span class="line">            int start = i;</span><br><span class="line">            //这里是判断尾数够不够k个来取决end指针的位置</span><br><span class="line">            int end = Math.min(ch.length - 1, start + k - 1);</span><br><span class="line">            //用异或运算反转 </span><br><span class="line">            while(start &lt; end){</span><br><span class="line">                char temp = ch[start];</span><br><span class="line">                ch[start] = ch[end];</span><br><span class="line">                ch[end] = temp;</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return new String(ch);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="替换数字：CR054"><a href="#替换数字：CR054" class="headerlink" title="替换数字：CR054"></a>替换数字：CR054</h2><p>没有什么技巧和难点！！！</p><p>代码：</p><p>import java.util.Scanner;</p><p>class Main {<br>    public static void main(String[] args) {<br>        Scanner in = new Scanner(System.in);<br>        String s = in.nextLine();<br>        StringBuilder sb = new StringBuilder();<br>        for (int i = 0; i &lt; s.length(); i++) {<br>            if (Character.isDigit(s.charAt(i))) {<br>                sb.append(“number”);<br>            }else sb.append(s.charAt(i));<br>        }<br>        System.out.println(sb);<br>    }<br>}</p><h2 id="反转字符串中的单词：LK151"><a href="#反转字符串中的单词：LK151" class="headerlink" title="反转字符串中的单词：LK151"></a>反转字符串中的单词：LK151</h2><ul><li>移除多余空格 : “the sky is blue”</li><li>字符串反转：”eulb si yks eht”</li><li>单词反转：”blue is sky the”</li><li>反转一次字符串</li><li>再反转一次单词即可</li></ul><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package org.example.数组字符串;</span><br><span class="line"></span><br><span class="line">public class num151 {</span><br><span class="line">    public String reverseWords(String s) {</span><br><span class="line">        // 1.去除首尾以及中间多余空格</span><br><span class="line">        StringBuilder sb = removeSpace(s);</span><br><span class="line">        // 2.反转整个字符串</span><br><span class="line">        reverseString(sb, 0, sb.length() - 1);</span><br><span class="line">        // 3.反转各个单词</span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private StringBuilder removeSpace(String s) {</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = s.length() - 1;</span><br><span class="line">        while (s.charAt(start) == ' ') start++;</span><br><span class="line">        while (s.charAt(end) == ' ') end--;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        while (start &lt;= end) {</span><br><span class="line">            char c = s.charAt(start);</span><br><span class="line">            if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') {</span><br><span class="line">                sb.append(c);</span><br><span class="line">            }</span><br><span class="line">            start++;</span><br><span class="line">        }</span><br><span class="line">        return sb;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 反转字符串指定区间[start, end]的字符</span><br><span class="line">     */</span><br><span class="line">    public void reverseString(StringBuilder sb, int start, int end) {</span><br><span class="line">        while (start &lt; end) {</span><br><span class="line">            char temp = sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void reverseEachWord(StringBuilder sb) {</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = 1;</span><br><span class="line">        int n = sb.length();</span><br><span class="line">        while (start &lt; n) {</span><br><span class="line">            while (end &lt; n &amp;&amp; sb.charAt(end) != ' ') {</span><br><span class="line">                end++;</span><br><span class="line">            }</span><br><span class="line">            reverseString(sb, start, end - 1);</span><br><span class="line">            start = end + 1;</span><br><span class="line">            end = start + 1;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="左旋转字符：CR055"><a href="#左旋转字符：CR055" class="headerlink" title="左旋转字符：CR055"></a>左旋转字符：CR055</h2><p>和上面的反转字符中的单词类似：</p><p>代码：</p><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        int n = Integer.parseInt(in.nextLine());        String s = in.nextLine();         int len = s.length();  //获取字符串长度    char[] chars = s.toCharArray();    reverseString(chars, 0, len - n - 1);  //反转前一段字符串，此时的字符串首尾是0,len - n - 1    reverseString(chars, len - n, len - 1);  //反转后一段字符串，此时的字符串首尾是len - n,len - 1    reverseString(chars, 0, len - 1);  //反转整个字符串    System.out.println(chars);}public static void reverseString(char[] ch, int start, int end) {    //异或法反转字符串，参照题目 344.反转字符串的解释    while (start &lt; end) {        ch[start] ^= ch[end];        ch[end] ^= ch[start];        ch[start] ^= ch[end];        start++;        end--;    }}}</code></pre><p>其中可以使用异或运算来进行反转：</p><p>public static void reverseString(char[] ch, int start, int end) {<br>    //异或法反转字符串，参照题目 344.反转字符串的解释<br>    while (start &lt; end) {<br>        ch[start] ^= ch[end];<br>        ch[end] ^= ch[start];<br>        ch[start] ^= ch[end];<br>        start++;<br>        end–;<br>    }<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day06</title>
      <link href="/2024/04/23/day06/"/>
      <url>/2024/04/23/day06/</url>
      
        <content type="html"><![CDATA[<h2 id="四数相加：LK454"><a href="#四数相加：LK454" class="headerlink" title="四数相加：LK454"></a>四数相加：LK454</h2><p>分别将两个数组合并并进行两数相加的和等于0；</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class num454 {</span><br><span class="line">    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int record = 0;</span><br><span class="line">        for (int num1 : nums1) {</span><br><span class="line">            for (int num2 : nums2) {</span><br><span class="line">                map.put(num1 + num2, map.getOrDefault(num1 + num2, 0) + 1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int num3 : nums3) {</span><br><span class="line">            for (int num4 : nums4) {</span><br><span class="line">                int target = 0 - (num3 + num4);</span><br><span class="line">                if (map.containsKey(target)){</span><br><span class="line">                    record = record + map.getOrDefault(target, 0);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return record;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="赎金信：LK383"><a href="#赎金信：LK383" class="headerlink" title="赎金信：LK383"></a>赎金信：LK383</h2><p>用数组遍历字符串一加一减，得到ransomNote字符对应的位置是否还是1，是就magazine不含有相应的字符！！！！</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">public class num383 {</span><br><span class="line">    public boolean canConstruct(String ransomNote, String magazine) {</span><br><span class="line">        int[] record = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; ransomNote.length(); i++) {</span><br><span class="line">            record[ransomNote.charAt(i) - 'a'] ++;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; magazine.length(); i++) {</span><br><span class="line">            record[magazine.charAt(i) - 'a'] --;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int chart : record) {</span><br><span class="line">            if (chart &gt; 0){</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="三数之和：LK015"><a href="#三数之和：LK015" class="headerlink" title="三数之和：LK015"></a>三数之和：LK015</h2><p>通过双指针的移动来控制三数之和；</p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和" style="zoom:200%;"><p>代码:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class num015 {</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        // 找出a + b + c = 0</span><br><span class="line">        // a = nums[i], b = nums[left], c = nums[right]</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) {</span><br><span class="line">            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br><span class="line">            if (nums[i] &gt; 0) {</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {  // 去重a</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (right &gt; left) {</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &gt; 0) {</span><br><span class="line">                    right--;</span><br><span class="line">                } else if (sum &lt; 0) {</span><br><span class="line">                    left++;</span><br><span class="line">                } else {</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="四数之和：LK018"><a href="#四数之和：LK018" class="headerlink" title="四数之和：LK018"></a>四数之和：LK018</h2><p>和三数之和一样只是在里面再套一层循环来控制起始的数！</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class num018 {</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        // 找出a + b + c = 0</span><br><span class="line">        // a = nums[i], b = nums[left], c = nums[right]</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) {</span><br><span class="line">            if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target){</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {  // 去重a，这里很细节，要先收集在去重，才能达到出去重复的数组</span><br><span class="line">                continue;                           //  {-2,-1,-1,2,3}nums[i] == nums[i + 1] 会导致收集{-1,-1,2}不成功</span><br><span class="line">            }</span><br><span class="line">            for (int j = i + 1; j &lt; nums.length; j++) {</span><br><span class="line">                // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br><span class="line">                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]){</span><br><span class="line">                    continue;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while (right &gt; left) {</span><br><span class="line">                    int sum = nums[i] + nums[left] + nums[right] + nums[j];</span><br><span class="line">                    if (sum &gt; target) {</span><br><span class="line">                        right--;</span><br><span class="line">                    } else if (sum &lt; target) {</span><br><span class="line">                        left++;</span><br><span class="line">                    } else {</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day05</title>
      <link href="/2024/04/22/day05/"/>
      <url>/2024/04/22/day05/</url>
      
        <content type="html"><![CDATA[<h2 id="有效的字母异位词-LK242"><a href="#有效的字母异位词-LK242" class="headerlink" title="有效的字母异位词:LK242"></a>有效的字母异位词:LK242</h2><p>利用HashMap 来存储对应字符的数值，一个字符串的字符 + 1，一个字符串的字符 - 1，将结果遍历存放入数组中，最后根据数组的值是否为 0 来进行判断</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class num242 {</span><br><span class="line">    public boolean isAnagram(String s, String t) {</span><br><span class="line">        int slen = s.length();</span><br><span class="line">        int tlen = t.length();</span><br><span class="line">        if (slen != tlen){</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        HashMap&lt;Character , Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; slen; i++) {</span><br><span class="line">            char ss = s.charAt(i);</span><br><span class="line">            char tt = t.charAt(i);</span><br><span class="line">            map.put(ss, map.getOrDefault(ss, 0) + 1);</span><br><span class="line">            map.put(tt, map.getOrDefault(tt, 0) - 1);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int[] res = new int[map.size()];</span><br><span class="line">        var ref = new Object() {</span><br><span class="line">            int i = 0;</span><br><span class="line">        };</span><br><span class="line">        map.forEach((key, value) -&gt; {</span><br><span class="line">            Integer val = map.get(key);</span><br><span class="line">            //System.out.println(val);</span><br><span class="line">            res[ref.i] = val;</span><br><span class="line">            ref.i = ref.i + 1;</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; res.length; j++) {</span><br><span class="line">            System.out.println(res[j]);</span><br><span class="line">            if (res[j] != 0){</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String s = "anagram";</span><br><span class="line">        String t = "nagaram";</span><br><span class="line">        num242 num242 = new num242();</span><br><span class="line">        boolean anagram = num242.isAnagram(s, t);</span><br><span class="line">        System.out.println(anagram);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他版本代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 242. 有效的字母异位词 字典解法</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(m+n) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> {</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">            record[s.charAt(i) - <span class="string">'a'</span>]++;     <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) {</span><br><span class="line">            record[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count: record) {</span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span>) {               <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="两个数组的交集-LK349"><a href="#两个数组的交集-LK349" class="headerlink" title="两个数组的交集:LK349"></a>两个数组的交集:LK349</h2><p>和上一题差不多，多了一步去重：</p><p>  if (! map.containsKey(nums1[i])){<br>                map.put(nums1[i], map.getOrDefault(nums1[i], 0) + 1);<br>            }</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class num349 {</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) {</span><br><span class="line">        int length1 = nums1.length;</span><br><span class="line">        int length2 = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; length1; i++) {</span><br><span class="line">            if (! map.containsKey(nums1[i])){</span><br><span class="line">                map.put(nums1[i], map.getOrDefault(nums1[i], 0) + 1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        for (int j = 0; j &lt; length2; j++) {</span><br><span class="line">            if (map.containsKey(nums2[j])){</span><br><span class="line">                map.put(nums2[j], map.getOrDefault(nums2[j], 0) + 1);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">        map.forEach((key, value) -&gt; {</span><br><span class="line">            //System.out.println(value);</span><br><span class="line">            if (value &gt;= 2){</span><br><span class="line">                res.add(key);</span><br><span class="line">                //System.out.println("---------------------------");</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        int[] result = new int[res.size()];</span><br><span class="line">        for (int i = 0; i &lt; res.size(); i++) {</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">            System.out.println(result[i]);</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] nums1 = {1,2,2,1};</span><br><span class="line">        int[] nums2 = {2,2};</span><br><span class="line">        num349 num349 = new num349();</span><br><span class="line">        int[] num = num349.intersection(nums1, nums2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他版本代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) {</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; resSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) {</span><br><span class="line">            set1.add(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//遍历数组2的过程中判断哈希表中是否存在该元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) {</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) {</span><br><span class="line">                resSet.add(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//方法1：将结果集合转为数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resSet.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法2：另外申请一个数组存放setRes中的元素,最后返回数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[resSet.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : resSet){</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="快乐数：LK202"><a href="#快乐数：LK202" class="headerlink" title="快乐数：LK202"></a>快乐数：LK202</h2><p>求和的过程中，sum会重复出现，这对解题很重要！</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.example.哈希;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line"></span><br><span class="line">public class num202 {</span><br><span class="line">    public boolean isHappy(int n) {</span><br><span class="line">        HashSet&lt;Integer&gt; record = new HashSet&lt;&gt;();</span><br><span class="line">        while (n != 1 &amp;&amp; !record.contains(n)){</span><br><span class="line">            record.add(n);</span><br><span class="line">            n = findNextNum(n);</span><br><span class="line">        }</span><br><span class="line">        return n == 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private int findNextNum(int n) {</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while(n &gt; 0){</span><br><span class="line">            int temp = n % 10;</span><br><span class="line">            sum += temp * temp;</span><br><span class="line">            n = n / 10;</span><br><span class="line">        }</span><br><span class="line">        return sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="两数之和：LK001"><a href="#两数之和：LK001" class="headerlink" title="两数之和：LK001"></a>两数之和：LK001</h2><p>通过 target - nums[i] 进行Map的一个映射关系</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) {</span><br><span class="line">    int[] res = new int[2];</span><br><span class="line">    if(nums == null || nums.length == 0){</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for(int i = 0; i &lt; nums.length; i++){</span><br><span class="line">        int temp = target - nums[i];   // 遍历当前元素，并在map中寻找是否有匹配的key</span><br><span class="line">        if(map.containsKey(temp)){</span><br><span class="line">            res[1] = i;</span><br><span class="line">            res[0] = map.get(temp);</span><br><span class="line">            break;</span><br><span class="line">        }</span><br><span class="line">        map.put(nums[i], i);    // 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br><span class="line">    }</span><br><span class="line">    return res;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day04</title>
      <link href="/2024/04/20/day04/"/>
      <url>/2024/04/20/day04/</url>
      
        <content type="html"><![CDATA[<h2 id="两两交换链表：LK029"><a href="#两两交换链表：LK029" class="headerlink" title="两两交换链表：LK029"></a>两两交换链表：LK029</h2><p>比较明显且容易想到的就是递归：</p><p>1.确定函数及参数返回值</p><p>2.确定终止条件</p><p>3.确定下一轮递归的条件和值</p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.example.链表;</span><br><span class="line"></span><br><span class="line">public class num024 {</span><br><span class="line">    public class ListNode {</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() {}</span><br><span class="line">        ListNode(int val) { this.val = val; }</span><br><span class="line">        ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line">    }</span><br><span class="line">    public ListNode swapPairs(ListNode head) {</span><br><span class="line">        // base case 退出提交</span><br><span class="line">        if(head == null || head.next == null) return head;</span><br><span class="line">        // 获取当前节点的下一个节点</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        // 进行递归</span><br><span class="line">        ListNode newNode = swapPairs(next.next);</span><br><span class="line">        // 这里进行交换</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        return next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除倒数第n个节点："><a href="#删除倒数第n个节点：" class="headerlink" title="删除倒数第n个节点："></a>删除倒数第n个节点：</h2><p>第一次的：通过遍历链表结合n确定删除的节点的位置</p><p>改进的：通过双指针法来</p><p>代码：（自己开始写的不能通过节点数为2的链表）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package org.example.链表;</span><br><span class="line"></span><br><span class="line">public class num019 {</span><br><span class="line">    public class ListNode {</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() {}</span><br><span class="line">        ListNode(int val) { this.val = val; }</span><br><span class="line">        ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line">    }</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) {</span><br><span class="line">        ListNode dummyNode = new ListNode(0);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        //确定总共的节点个数</span><br><span class="line">        int count = 0;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        while (p != null){</span><br><span class="line">            count ++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        if (count == 1){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        //确定节点在链表的位置</span><br><span class="line">        int index = count - n;</span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        for (int i = 1; i &lt; index; i++) {</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        }</span><br><span class="line">        //当前要删除的节点</span><br><span class="line">        ListNode cur = prev.next;</span><br><span class="line">        //将指针跳过删除节点就行</span><br><span class="line">        ListNode next = prev.next.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码：（改进版）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>{</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fastIndex</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slowIndex</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要快慢指针相差 n 个结点即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n  ; i++){ </span><br><span class="line">        fastIndex = fastIndex.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fastIndex != <span class="literal">null</span>){</span><br><span class="line">        fastIndex = fastIndex.next;</span><br><span class="line">        slowIndex = slowIndex.next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时 slowIndex 的位置就是待删除元素的前一个位置。</span></span><br><span class="line">    <span class="comment">//具体情况可自己画一个链表长度为 3 的图来模拟代码来理解</span></span><br><span class="line">    slowIndex.next = slowIndex.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="环形链表系列问题：LK142"><a href="#环形链表系列问题：LK142" class="headerlink" title="环形链表系列问题：LK142"></a>环形链表系列问题：LK142</h2><p>1.主要通过快慢指针来进行判断是否存在环</p><p>2.通过第一次相遇的位置得到数学逻辑求出入环口</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package org.example.链表;</span><br><span class="line"></span><br><span class="line">public class num142 {</span><br><span class="line">    public class ListNode {</span><br><span class="line">        int val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode() {}</span><br><span class="line">        ListNode(int val) { this.val = val; }</span><br><span class="line">        ListNode(int val, ListNode next) { this.val = val; this.next = next; }</span><br><span class="line">    }</span><br><span class="line">    public ListNode detectCycle(ListNode head) {</span><br><span class="line">        //运用快慢指针来进行判断是否存在环</span><br><span class="line">        //走两步一次</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        //走一步一次</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null){</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if (slow == fast) {// 有环</span><br><span class="line">                ListNode index1 = fast;</span><br><span class="line">                ListNode index2 = head;</span><br><span class="line">                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span><br><span class="line">                while (index1 != index2) {</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                }</span><br><span class="line">                return index1;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day03</title>
      <link href="/2024/04/20/day03/"/>
      <url>/2024/04/20/day03/</url>
      
        <content type="html"><![CDATA[<p>day03<br>删除链表节点：LK203<br>删除节点：<br>1.单链表只改变删除节点上一个节点的指针，让它指向被删除的节点的下一个节点就行</p><p>2.双向链表只改变被删除节点上一个节点的next指针，让它指向被删除的节点的下一个节点，并且被删除的节点的下一个节点prev指针指向被删除节点上一个节点</p><p>注：可以使用哨兵节点来简化头节点的删除</p><p>代码：</p><p>package org.example.链表;</p><p>public class num203 {</p><pre><code>public class ListNode {    int val;    ListNode next;    ListNode() {}    ListNode(int val) { this.val = val; }    ListNode(int val, ListNode next) { this.val = val; this.next = next; }}public ListNode removeElements(ListNode head, int val) {    if (head == null){        return head;    }    ListNode s = new ListNode(0, head);//定义一个哨兵指向头结点    ListNode prev = s;    ListNode curr = head;    while (curr != null){        if (curr.val == val){            prev.next = curr.next;        }else {            prev = curr;        }        curr = curr.next;    }    return s.next;}</code></pre><p>}<br>设计链表：LK707<br>1.主要通过node = node.next在node ！= null 的情况下来实现链表的遍历</p><p>2.这题运用到了</p><p>for (int i = 0; i &lt; index; i++) {//index - 1<br>    pred = pred.next;<br>}<br>来定位删除节点的位置</p><p>代码：</p><p>package org.example.链表;</p><p>public class num707 {<br>    class MyLinkedList {<br>        public class ListNode {<br>            int val;<br>            ListNode next;<br>            ListNode() {}<br>            ListNode(int val) { this.val = val; }<br>            ListNode(int val, ListNode next) { this.val = val; this.next = next; }<br>        }</p><pre><code>    int size;    ListNode head;    public MyLinkedList() {        size = 0;        head = new ListNode(0);    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size){            return -1;        }        ListNode cur = head;        for (int i = 0; i &lt;= index; i++) {            cur = cur.next;        }        return cur.val;    }    public void addAtHead(int val) {        addAtIndex(0, val);    }    public void addAtTail(int val) {        addAtIndex(size, val);    }    public void addAtIndex(int index, int val) {        if (index &gt; size){            return;        }        if (index &lt; 0){            index = 0;        }        size ++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) {//index - 1            pred = pred.next;        }        ListNode added = new ListNode(val);        ListNode next = pred.next;        pred.next = added;        added.next = next;    }    public void deleteAtIndex(int index) {        if (index &gt; size || index &lt; 0){            return;        }        //创建哨兵节点方便节点删除        ListNode s = new ListNode(-1, head);        //找到要删除的节点的上一个节点        ListNode prevDeleted = head;        for (int i = 0; i &lt; index; i++) {//index - 1            prevDeleted = prevDeleted.next;        }        prevDeleted.next = prevDeleted.next.next;    }}</code></pre><p>}<br>class ListNode{<br>    int val;<br>    ListNode next,prev;<br>    ListNode() {};<br>    ListNode(int val){<br>        this.val = val;<br>    }<br>}</p><p>class MyLinkedList {  </p><pre><code>//记录链表中元素的数量int size;//记录链表的虚拟头结点和尾结点ListNode head,tail;public MyLinkedList() &amp;#123;    //初始化操作    this.size = 0;    this.head = new ListNode(0);    this.tail = new ListNode(0);    //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！    head.next=tail;    tail.prev=head;&amp;#125;public int get(int index) &amp;#123;    //判断index是否有效    if(index&lt;0 || index&gt;=size)&amp;#123;        return -1;    &amp;#125;    ListNode cur = this.head;    //判断是哪一边遍历时间更短    if(index &gt;= size / 2)&amp;#123;        //tail开始        cur = tail;        for(int i=0; i&lt; size-index; i++)&amp;#123;            cur = cur.prev;        &amp;#125;    &amp;#125;else&amp;#123;        for(int i=0; i&lt;= index; i++)&amp;#123;            cur = cur.next;         &amp;#125;    &amp;#125;    return cur.val;&amp;#125;public void addAtHead(int val) &amp;#123;    //等价于在第0个元素前添加    addAtIndex(0,val);&amp;#125;public void addAtTail(int val) &amp;#123;    //等价于在最后一个元素(null)前添加    addAtIndex(size,val);&amp;#125;public void addAtIndex(int index, int val) &amp;#123;    //index大于链表长度    if(index&gt;size)&amp;#123;        return;    &amp;#125;    //index小于0    if(index&lt;0)&amp;#123;        index = 0;    &amp;#125;    size++;    //找到前驱    ListNode pre = this.head;    for(int i=0; i&lt;index; i++)&amp;#123;        pre = pre.next;    &amp;#125;    //新建结点    ListNode newNode = new ListNode(val);    newNode.next = pre.next;    pre.next.prev = newNode;    newNode.prev = pre;    pre.next = newNode;    &amp;#125;public void deleteAtIndex(int index) &amp;#123;    //判断索引是否有效    if(index&lt;0 || index&gt;=size)&amp;#123;        return;    &amp;#125;    //删除操作    size--;    ListNode pre = this.head;    for(int i=0; i&lt;index; i++)&amp;#123;        pre = pre.next;    &amp;#125;    pre.next.next.prev = pre;    pre.next = pre.next.next;&amp;#125;</code></pre><p>}<br>反转链表：LK206<br>在指针遍历推进并进行指针反向的过程中定义的临时节点很重要，主要用来记录下一个一个节点，可以类比于数组变量中定义的临时变量记录下一个数值的效果</p><p>代码：</p><p>package org.example.链表;</p><p>public class num206 {<br>    public class ListNode {<br>        int val;<br>        ListNode next;<br>        ListNode() {}<br>        ListNode(int val) { this.val = val; }<br>        ListNode(int val, ListNode next) { this.val = val; this.next = next; }<br>    }<br>    //双指针法暴力遍历反向<br>    public ListNode reverseList(ListNode head) {<br>        if (head == null){<br>            return head;<br>        }<br>        ListNode curr = head;<br>        ListNode temp = null;<br>        ListNode prev = null;<br>        while (curr != null){<br>            temp= curr.next;//记录下一个节点<br>            curr.next = prev;//指针反向<br>            //向前推进遍历<br>            prev =curr;<br>            curr = temp;<br>        }<br>        return prev;<br>    }<br>}<br>// 递归<br>class Solution {<br>    public ListNode reverseList(ListNode head) {<br>        return reverse(null, head);<br>    }</p><pre><code>private ListNode reverse(ListNode prev, ListNode cur) &amp;#123;    if (cur == null) &amp;#123;        return prev;    &amp;#125;    ListNode temp = null;    temp = cur.next;// 先保存下一个节点    cur.next = prev;// 反转    // 更新prev、cur位置    // prev = cur;    // cur = temp;    return reverse(cur, temp);&amp;#125;</code></pre><p>}<br>// 从后向前递归<br>class Solution {<br>    ListNode reverseList(ListNode head) {<br>        // 边缘条件判断<br>        if(head == null) return null;<br>        if (head.next == null) return head;</p><pre><code>    // 递归调用，翻转第二个节点开始往后的链表    ListNode last = reverseList(head.next);    // 翻转头节点与第二个节点的指向    head.next.next = head;    // 此时的 head 节点为尾节点，next 需要指向 NULL    head.next = null;    return last;&amp;#125; </code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day02</title>
      <link href="/2024/04/20/day02/"/>
      <url>/2024/04/20/day02/</url>
      
        <content type="html"><![CDATA[<p>day02<br>双指针法：LK997<br>通过数组两端的指针逐步向中间遍历：其中终止条件 while (right &gt;= left) 不能少 ‘=’ 当临界条件 int[] nums = {1};这种情况少了的话会判断不了</p><p>代码：</p><p>package org.example.数组字符串;</p><p>public class num997 {<br>    public int[] sortedSquares(int[] nums) {<br>        //接收结果<br>        int[] result = new int[nums.length];<br>       int left = 0;<br>       int right = nums.length - 1;<br>       int resIndex = nums.length - 1;<br>       while (right &gt;= left){<br>           int leftPow = nums[left] * nums[left];<br>           int rightPow = nums[right] * nums[right];</p><pre><code>       //左边的平方大于右边       if (leftPow &gt; rightPow){           left ++;           result[resIndex] = leftPow;       }else {           //右边的平方大于等于左边           result[resIndex] = rightPow;           right --;       }       resIndex --;   }    return result;}public static void main(String[] args) {    int[] nums = {-7,-3,2,3,11};    num997 pow = new num997();    int[] p = pow.sortedSquares(nums);    for (int pp : p) {        System.out.println(pp);    }}</code></pre><p>}<br>滑动窗口法：LK209<br>这题我求取的是连续最小的子数组，但是这题是求取任意的最小子数组，看错变成了等于了</p><p>代码：</p><p>package org.example.数组字符串;</p><p>public class num209 {<br>    //滑动窗口法<br>    public int minSubArrayLen(int target, int[] nums) {<br>        int result = Integer.MAX_VALUE;<br>        int slow = 0;<br>        int fast = 0;<br>        int sum = nums[0];//记录窗口内的和与target进行比较<br>        while (fast &lt; nums.length){<br>            //sum &lt; target<br>            if (sum &lt; target){<br>                if (fast != nums.length - 1){<br>                    fast ++;<br>                    sum += nums[fast];<br>                }else {<br>                    break;<br>                }<br>            }<br>            //sum &gt; target<br>            else if (sum &gt; target){<br>                sum -= nums[slow];<br>                slow ++;<br>            }else {<br>                //sum = target<br>                result = Math.min(result, fast - slow + 1);<br>                if (fast != nums.length - 1){<br>                    fast ++;<br>                    sum += nums[fast];<br>                }else {<br>                    break;<br>                }<br>            }<br>        }<br>        return result == Integer.MAX_VALUE ? 0 : result;<br>    }</p><pre><code>public static void main(String[] args) {    int[] nums = {1,2,3,4,5};    num209 num209 = new num209();    int res = num209.minSubArrayLen(11, nums);    System.out.println(res);}</code></pre><p>}<br>最小子数组代码：</p><p>public int minSubArrayLen(int target, int[] nums) {<br>    int result = Integer.MAX_VALUE;<br>    int slow = 0;<br>    int fast = 0;<br>    int sum = nums[0];//记录窗口内的和与target进行比较<br>    while (fast &lt; nums.length){<br>        //sum &lt; target<br>        if (sum &lt; target){<br>            if (fast != nums.length - 1){<br>                fast ++;<br>                sum += nums[fast];<br>            }else {<br>                break;<br>            }<br>        }<br>        //sum &gt; target<br>        else if (sum &gt; target){<br>            result = Math.min(result, fast - slow + 1);<br>            sum -= nums[slow];<br>            slow ++;<br>        }else {<br>            //sum = target<br>            result = Math.min(result, fast - slow + 1);<br>            if (fast != nums.length - 1){<br>                fast ++;<br>                sum += nums[fast];<br>            }else {<br>                break;<br>            }<br>        }<br>    }<br>    return result == Integer.MAX_VALUE ? 0 : result;<br>}<br>public int minSubArrayLen(int s, int[] nums) {<br>    int left = 0;<br>    int sum = 0;<br>    int result = Integer.MAX_VALUE;<br>    for (int right = 0; right &lt; nums.length; right++) {<br>        sum += nums[right];<br>        while (sum &gt;= s) {<br>            result = Math.min(result, right - left + 1);<br>            sum -= nums[left++];<br>        }<br>    }<br>    return result == Integer.MAX_VALUE ? 0 : result;<br>}<br>边界条件的合理处理：Lk059<br>这题难点就是终止条件以及边界条件左闭右开 [ ) 的一个判断比较难想到</p><p>代码：</p><p>package org.example.数组字符串;</p><p>public class num059 {<br>    //循环不变量原则  左闭右开[ )<br>    public int[][] generateMatrix(int n) {<br>        int[][] nums = new int[n][n];<br>        int startX = 0, startY = 0;  // 每一圈的起始点<br>        int offset = 1;<br>        int count = 1;  // 矩阵中需要填写的数字<br>        int loop = 1; // 记录当前的圈数<br>        int i, j; // j 代表列, i 代表行;</p><pre><code>    while (loop &lt;= n / 2) &amp;#123;        // 顶部        // 左闭右开，所以判断循环结束时， j 不能等于 n - offset        for (j = startY; j &lt; n - offset; j++) &amp;#123;            nums[startX][j] = count++;        &amp;#125;        // 右列        // 左闭右开，所以判断循环结束时， i 不能等于 n - offset        for (i = startX; i &lt; n - offset; i++) &amp;#123;            nums[i][j] = count++;        &amp;#125;        // 底部        // 左闭右开，所以判断循环结束时， j != startY        for (; j &gt; startY; j--) &amp;#123;            nums[i][j] = count++;        &amp;#125;        // 左列        // 左闭右开，所以判断循环结束时， i != startX        for (; i &gt; startX; i--) &amp;#123;            nums[i][j] = count++;        &amp;#125;        startX++;        startY++;        offset++;        loop++;    &amp;#125;    if (n % 2 == 1) &amp;#123; // n 为奇数时，单独处理矩阵中心的值        nums[startX][startY] = count;    &amp;#125;    return nums;&amp;#125;</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>day01</title>
      <link href="/2024/04/20/day01/"/>
      <url>/2024/04/20/day01/</url>
      
        <content type="html"><![CDATA[<p>day01<br>二分查找：LK704<br>1.主要注意点就是区间的选择</p><p>[ ] 或者 [ ) 其分别对应的终止条件是 right &gt;= left 和 right &gt; left</p><p>代码：</p><p>package org.example.二分查找;</p><p>import org.example.数组.LK704;<br>//二分搜索法</p><p>/**</p><ul><li>总结：</li><li>1：[]左闭右闭的区间对应的条件right &gt;= left 极限时[1,1]合法</li><li>2：[)左开右闭的区间对应的条件right &gt; left 极限时[1,1)不合法所以要求rightindex &gt; leftindex</li><li></li><li>二分查找要求区间合法，主要注意边界值和目标值的关系，要求边界包含目标，不然就返回 -1</li></ul><p> */</p><p>public class num704 {<br>    //输入: nums = [-1,0,3,5,9,12], target = 9<br>    //输出: 4<br>    //解释: 9 出现在 nums 中并且下标为 4<br>    public int search(int[] nums, int target) {<br>        //采用左闭右闭区间<br>        int left = 0;<br>        int length = nums.length;<br>        int right = length - 1;<br>        if (nums[left] &gt; target || target &gt; nums[right])<br>        {<br>            return -1;<br>        }<br>        while (right &gt;= left ){<br>            int middle = left + ((right - left) &gt;&gt; 1);//取中间值<br>            //target在左区间<br>            if (nums[middle] &gt; target){<br>                right = middle - 1;<br>            }else if (target &gt; nums[middle]){<br>                //target在右区间<br>                left = middle + 1;<br>            }else {<br>                //找到了target<br>                return middle;<br>            }<br>        }<br>        return -1;<br>    }</p><pre><code>public static void main(String[] args) {    int[]nums = {-1,0,3,5,9,12};    int target = 9;    num704 search = new num704();    int result = search.search(nums, target);    System.out.println(result);}</code></pre><p>}<br>快慢指针：LK027<br>1.快指针进行遍历更新操作，而慢指针进行新数组的一个接收存储记录</p><p>代码：</p><p>package org.example.二分查找;</p><p>public class num027 {</p><pre><code>public int removeElement(int[] nums, int val) {    //输入：nums = [3,2,2,3], val = 3    //输出：2, nums = [2,2]    //数组元素只能覆盖不能真正删除    int slow = 0;//负责接收    int fast = 0;//负责去除及更新    int length = nums.length;    for (int i = 0; i &lt; length; i++) {        if (nums[fast] != val){            nums[slow ++] = nums[fast];        }        fast ++;    }    return slow;}</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> 代码随想录每日刷题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
