<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程玉春的博客</title>
  
  <subtitle>Welcome to My blog</subtitle>
  <link href="https://cyc199811.github.io/atom.xml" rel="self"/>
  
  <link href="https://cyc199811.github.io/"/>
  <updated>2024-05-13T22:02:00.121Z</updated>
  <id>https://cyc199811.github.io/</id>
  
  <author>
    <name>程玉春</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day021</title>
    <link href="https://cyc199811.github.io/2024/05/14/day28/"/>
    <id>https://cyc199811.github.io/2024/05/14/day28/</id>
    <published>2024-05-13T21:53:41.257Z</published>
    <updated>2024-05-13T22:02:00.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h2><h3 id="思路：和077差不多，多加一个sum求和和目标值比较，以及回溯sum-i"><a href="#思路：和077差不多，多加一个sum求和和目标值比较，以及回溯sum-i" class="headerlink" title="思路：和077差不多，多加一个sum求和和目标值比较，以及回溯sum - i"></a>思路：和077差不多，多加一个sum求和和目标值比较，以及回溯sum - i</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package org.example.回溯;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class num216 {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {</span><br><span class="line">        backingTrack(k, n, 1, 0);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void backingTrack(int k, int n, int startNum, int sum){</span><br><span class="line">        // 减枝</span><br><span class="line">        if (sum &gt; n) {</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        if (path.size() == k &amp;&amp; sum == n){</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        for (int i = startNum; i &lt;= 9 - (k - path.size()) + 1; i++) {//横向遍历</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            backingTrack(k, n,i + 1, sum);//递归</span><br><span class="line">            path.removeLast();//回溯</span><br><span class="line">            sum -= i;//回溯</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><h3 id="思路：创建对应数字与字符串的索引对应，然后对每一个字符串进行回溯"><a href="#思路：创建对应数字与字符串的索引对应，然后对每一个字符串进行回溯" class="headerlink" title="思路：创建对应数字与字符串的索引对应，然后对每一个字符串进行回溯"></a>思路：创建对应数字与字符串的索引对应，然后对每一个字符串进行回溯</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package org.example.回溯;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class num017 {</span><br><span class="line">    ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder temp = new StringBuilder();</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) {</span><br><span class="line">        //剪枝</span><br><span class="line">        if (digits == "" || digits.length() == 0){</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""</span><br><span class="line">        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};</span><br><span class="line">        backTracking(digits, numString, 0);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public void backTracking(String digits, String[] numString, int num){</span><br><span class="line">        if (num == digits.length()){</span><br><span class="line">            result.add(temp.toString());</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        //获取对应的字符串</span><br><span class="line">        String str = numString[digits.charAt(num) - '0'];</span><br><span class="line">        for (int i = 0; i &lt; str.length(); i++) {//横向遍历</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numString, num + 1);//递归纵向遍历</span><br><span class="line">            temp.deleteCharAt(temp.length() -  1);//回溯</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;216-组合总和-III&quot;&gt;&lt;a href=&quot;#216-组合总和-III&quot; class=&quot;headerlink&quot; title=&quot;216. 组合总和 III&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://cyc199811.github.io/2024/05/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://cyc199811.github.io/2024/05/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-05-13T02:35:49.622Z</published>
    <updated>2024-05-13T21:53:35.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="按序打印：LK1114"><a href="#按序打印：LK1114" class="headerlink" title="按序打印：LK1114"></a>按序打印：LK1114</h2><h3 id="思路：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除"><a href="#思路：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除" class="headerlink" title="思路：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除"></a>思路：使用线程等待的方式实现执行屏障，使用释放线程等待的方式实现屏障消除</h3><img src="/2024/05/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20240513103906660.png" alt="image-20240513103906660" style="zoom:200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package org.example.多线程;</span><br><span class="line"></span><br><span class="line">class Foo {</span><br><span class="line"></span><br><span class="line">    private boolean firstFinished;</span><br><span class="line">    private boolean secondFinished;</span><br><span class="line">    private Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public Foo() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void first(Runnable printFirst) throws InterruptedException {</span><br><span class="line"></span><br><span class="line">        synchronized (lock) {</span><br><span class="line">            // printFirst.run() outputs "first". Do not change or remove this line.</span><br><span class="line">            printFirst.run();</span><br><span class="line">            firstFinished = true;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void second(Runnable printSecond) throws InterruptedException {</span><br><span class="line"></span><br><span class="line">        synchronized (lock) {</span><br><span class="line">            while (!firstFinished) {</span><br><span class="line">                lock.wait();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // printSecond.run() outputs "second". Do not change or remove this line.</span><br><span class="line">            printSecond.run();</span><br><span class="line">            secondFinished = true;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void third(Runnable printThird) throws InterruptedException {</span><br><span class="line"></span><br><span class="line">        synchronized (lock) {</span><br><span class="line">            while (!secondFinished) {</span><br><span class="line">                lock.wait();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // printThird.run() outputs "third". Do not change or remove this line.</span><br><span class="line">            printThird.run();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="交替打印-FooBar"><a href="#交替打印-FooBar" class="headerlink" title="交替打印 FooBar"></a><a href="https://leetcode.cn/problems/print-foobar-alternately/">交替打印 FooBar</a></h2><h3 id="思路：设置异步锁，保证两个线程是交替进行"><a href="#思路：设置异步锁，保证两个线程是交替进行" class="headerlink" title="思路：设置异步锁，保证两个线程是交替进行"></a>思路：设置异步锁，保证两个线程是交替进行</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package org.example.多线程;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">//synchronized</span><br><span class="line">class FooBar1 {</span><br><span class="line"></span><br><span class="line">    private int n;</span><br><span class="line"></span><br><span class="line">    private final Object lock;</span><br><span class="line"></span><br><span class="line">    private int flag;</span><br><span class="line"></span><br><span class="line">    public FooBar1(int n) {</span><br><span class="line">        this.n = n;</span><br><span class="line">        this.flag = 0;</span><br><span class="line">        this.lock = new Object();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void foo(Runnable printFoo) throws InterruptedException {</span><br><span class="line">        for (int i = 0; i &lt; n; i++) {</span><br><span class="line">            synchronized (lock) {</span><br><span class="line">                while (flag == 1) {</span><br><span class="line">                    lock.wait();</span><br><span class="line">                }</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = 1;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void bar(Runnable printBar) throws InterruptedException {</span><br><span class="line">        for (int i = 0; i &lt; n; i++) {</span><br><span class="line">            synchronized (lock) {</span><br><span class="line">                while (flag == 0) {</span><br><span class="line">                    lock.wait();</span><br><span class="line">                }</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = 0;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="1116-打印零与奇偶数"><a href="#1116-打印零与奇偶数" class="headerlink" title="1116. 打印零与奇偶数"></a><a href="https://leetcode.cn/problems/print-zero-even-odd/">1116. 打印零与奇偶数</a></h2><h3 id="思路：每一轮迭代分为四步，-先0-奇数-再0-偶数-，用两个开关即可以控制它们的顺序。"><a href="#思路：每一轮迭代分为四步，-先0-奇数-再0-偶数-，用两个开关即可以控制它们的顺序。" class="headerlink" title="思路：每一轮迭代分为四步，[先0] [奇数] [再0] [偶数]，用两个开关即可以控制它们的顺序。"></a>思路：每一轮迭代分为四步，[先0] [奇数] [再0] [偶数]，用两个开关即可以控制它们的顺序。</h3><h3 id="具体的先后顺序控制方法与题1115-交替打印-FooBar是一样的。"><a href="#具体的先后顺序控制方法与题1115-交替打印-FooBar是一样的。" class="headerlink" title="具体的先后顺序控制方法与题1115. 交替打印 FooBar是一样的。"></a>具体的先后顺序控制方法与题1115. 交替打印 FooBar是一样的。</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package org.example.多线程;</span><br><span class="line"></span><br><span class="line">import java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line">class ZeroEvenOdd {</span><br><span class="line">    private int n;</span><br><span class="line">    private volatile boolean needZero;</span><br><span class="line">    private volatile boolean needOdd;</span><br><span class="line"></span><br><span class="line">    public ZeroEvenOdd(int n) {</span><br><span class="line">        this.n = n;</span><br><span class="line">        needZero = true;</span><br><span class="line">        needOdd = true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // printNumber.accept(x) outputs "x", where x is an integer.</span><br><span class="line">    public void zero(IntConsumer printNumber) throws InterruptedException {</span><br><span class="line">        for (int i = 0; i &lt; n; ) {</span><br><span class="line">            if (needZero) {</span><br><span class="line">                printNumber.accept(0);</span><br><span class="line">                i++;</span><br><span class="line">                needZero = false;</span><br><span class="line">            } else {</span><br><span class="line">                Thread.yield();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void even(IntConsumer printNumber) throws InterruptedException {</span><br><span class="line">        for (int i = 2; i &lt;= n; ) {</span><br><span class="line">            if (!needZero &amp;&amp; !needOdd) {</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                i += 2;</span><br><span class="line">                needZero = true;</span><br><span class="line">                needOdd = true;</span><br><span class="line">            } else {</span><br><span class="line">                Thread.yield();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void odd(IntConsumer printNumber) throws InterruptedException {</span><br><span class="line">        for (int i = 1; i &lt;= n; ) {</span><br><span class="line">            if (!needZero &amp;&amp; needOdd) {</span><br><span class="line">                printNumber.accept(i);</span><br><span class="line">                i += 2;</span><br><span class="line">                needZero = true;</span><br><span class="line">                needOdd = false;</span><br><span class="line">            } else {</span><br><span class="line">                Thread.yield();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;按序打印：LK1114&quot;&gt;&lt;a href=&quot;#按序打印：LK1114&quot; class=&quot;headerlink&quot; title=&quot;按序打印：LK1114&quot;&gt;&lt;/a&gt;按序打印：LK1114&lt;/h2&gt;&lt;h3 id=&quot;思路：使用线程等待的方式实现执行屏障，使用释放线程等待的方</summary>
      
    
    
    
    <category term="多线程" scheme="https://cyc199811.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程锁的机制" scheme="https://cyc199811.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>day021</title>
    <link href="https://cyc199811.github.io/2024/05/13/day27/"/>
    <id>https://cyc199811.github.io/2024/05/13/day27/</id>
    <published>2024-05-13T01:47:34.202Z</published>
    <updated>2024-05-13T21:54:17.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合：LK077"><a href="#组合：LK077" class="headerlink" title="组合：LK077"></a>组合：LK077</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package org.example.回溯算法;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class LK077 {</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {</span><br><span class="line">        combineHelper(n, k, 1);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</span><br><span class="line">     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。</span><br><span class="line">     */</span><br><span class="line">    private void combineHelper(int n, int k, int startIndex){</span><br><span class="line">        //终止条件</span><br><span class="line">        if (path.size() == k){</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++){//广度遍历，横向</span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + 1);//深度遍历，纵向</span><br><span class="line">            path.removeLast();//回溯</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合：LK077&quot;&gt;&lt;a href=&quot;#组合：LK077&quot; class=&quot;headerlink&quot; title=&quot;组合：LK077&quot;&gt;&lt;/a&gt;组合：LK077&lt;/h2&gt;&lt;h3 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>day019</title>
    <link href="https://cyc199811.github.io/2024/05/12/day24/"/>
    <id>https://cyc199811.github.io/2024/05/12/day24/</id>
    <published>2024-05-12T09:15:35.003Z</published>
    <updated>2024-05-13T01:37:27.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉搜索树最近公共祖先：LK235"><a href="#二叉搜索树最近公共祖先：LK235" class="headerlink" title="二叉搜索树最近公共祖先：LK235"></a>二叉搜索树最近公共祖先：LK235</h2><h3 id="思路：利用后序遍历由下向上遍历"><a href="#思路：利用后序遍历由下向上遍历" class="headerlink" title="思路：利用后序遍历由下向上遍历"></a>思路：利用后序遍历由下向上遍历</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class LK235 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</span><br><span class="line">        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        return root;</span><br><span class="line">     }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉搜索树中的插入操作：LK701"><a href="#二叉搜索树中的插入操作：LK701" class="headerlink" title="二叉搜索树中的插入操作：LK701"></a>二叉搜索树中的插入操作：LK701</h2><h3 id="思路：根据二叉搜索树的左边节点小于根节点，有边节点大于根节点的性质，分别向两边递归查找"><a href="#思路：根据二叉搜索树的左边节点小于根节点，有边节点大于根节点的性质，分别向两边递归查找" class="headerlink" title="思路：根据二叉搜索树的左边节点小于根节点，有边节点大于根节点的性质，分别向两边递归查找"></a>思路：根据二叉搜索树的左边节点小于根节点，有边节点大于根节点的性质，分别向两边递归查找</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK701 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return new TreeNode(val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (root.val &lt; val){</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">            //return right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (root.val &gt; val){</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">            //return left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Solution1 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) {</span><br><span class="line">        if (root == null) return new TreeNode(val);</span><br><span class="line">        TreeNode newRoot = root;</span><br><span class="line">        TreeNode pre = root;</span><br><span class="line">        while (root != null) {</span><br><span class="line">            pre = root;</span><br><span class="line">            if (root.val &gt; val) {</span><br><span class="line">                root = root.left;</span><br><span class="line">            } else if (root.val &lt; val) {</span><br><span class="line">                root = root.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        if (pre.val &gt; val) {</span><br><span class="line">            pre.left = new TreeNode(val);</span><br><span class="line">        } else {</span><br><span class="line">            pre.right = new TreeNode(val);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return newRoot;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除二叉搜索树中的节点：LK450"><a href="#删除二叉搜索树中的节点：LK450" class="headerlink" title="删除二叉搜索树中的节点：LK450"></a>删除二叉搜索树中的节点：LK450</h2><h3 id="思路：确定递归终止条件，然后做好删除节点后它的子节点的分配"><a href="#思路：确定递归终止条件，然后做好删除节点后它的子节点的分配" class="headerlink" title="思路：确定递归终止条件，然后做好删除节点后它的子节点的分配"></a>思路：确定递归终止条件，然后做好删除节点后它的子节点的分配</h3><img src="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="450.删除二叉搜索树中的节点" style="zoom:200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK450 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line">        if (root.val == key){</span><br><span class="line">            if (root.left == null){</span><br><span class="line">                return root.right;</span><br><span class="line">            }else if (root.right == null){</span><br><span class="line">                return root.left;</span><br><span class="line">            }</span><br><span class="line">            //其中的else操作左右都不为空的手法最为重要</span><br><span class="line">            else {</span><br><span class="line">               TreeNode cur =  root.right;</span><br><span class="line">               while (cur.left != null){</span><br><span class="line">                   cur = cur.left;</span><br><span class="line">               }</span><br><span class="line">               cur.left = root.left;</span><br><span class="line">               return root.right;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        if (root.val &gt; key){</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        }</span><br><span class="line">        if (root.val &lt; key){</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        }</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">    // 解法1(最好理解的版本)</span><br><span class="line">    class Solution {</span><br><span class="line">        public TreeNode deleteNode(TreeNode root, int key) {</span><br><span class="line">            if (root == null) return root;</span><br><span class="line">            if (root.val == key) {</span><br><span class="line">                if (root.left == null) {</span><br><span class="line">                    return root.right;</span><br><span class="line">                } else if (root.right == null) {</span><br><span class="line">                    return root.left;</span><br><span class="line">                } else {</span><br><span class="line">                    TreeNode cur = root.right;</span><br><span class="line">                    while (cur.left != null) {</span><br><span class="line">                        cur = cur.left;</span><br><span class="line">                    }</span><br><span class="line">                    cur.left = root.left;</span><br><span class="line">                    root = root.right;</span><br><span class="line">                    return root;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">            if (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉搜索树最近公共祖先：LK235&quot;&gt;&lt;a href=&quot;#二叉搜索树最近公共祖先：LK235&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树最近公共祖先：LK235&quot;&gt;&lt;/a&gt;二叉搜索树最近公共祖先：LK235&lt;/h2&gt;&lt;h3 id=&quot;思路：利用</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>day020</title>
    <link href="https://cyc199811.github.io/2024/05/12/day25/"/>
    <id>https://cyc199811.github.io/2024/05/12/day25/</id>
    <published>2024-05-12T09:12:22.978Z</published>
    <updated>2024-05-13T01:36:35.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="修剪二叉搜索树：LK669"><a href="#修剪二叉搜索树：LK669" class="headerlink" title="修剪二叉搜索树：LK669"></a>修剪二叉搜索树：LK669</h2><h3 id="思路：和删除二叉搜索树差不多，只是多了一个范围"><a href="#思路：和删除二叉搜索树差不多，只是多了一个范围" class="headerlink" title="思路：和删除二叉搜索树差不多，只是多了一个范围"></a>思路：和删除二叉搜索树差不多，只是多了一个范围</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK669 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) {</span><br><span class="line"></span><br><span class="line">        if (root == null){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (root.val &lt; low){</span><br><span class="line">            TreeNode right = trimBST(root.right, low, high);//修剪完再返回</span><br><span class="line">            return right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (root.val &gt; high){</span><br><span class="line">            TreeNode left = trimBST(root.left, low, high);//修剪完再返回</span><br><span class="line">            return left;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">    class Solution {</span><br><span class="line">        //iteration</span><br><span class="line">        public TreeNode trimBST(TreeNode root, int low, int high) {</span><br><span class="line">            if(root == null)</span><br><span class="line">                return null;</span><br><span class="line">            while(root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)){</span><br><span class="line">                if(root.val &lt; low)</span><br><span class="line">                    root = root.right;</span><br><span class="line">                else</span><br><span class="line">                    root = root.left;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            TreeNode curr = root;</span><br><span class="line"></span><br><span class="line">            //deal with root's left sub-tree, and deal with the value smaller than low.</span><br><span class="line">            while(curr != null){</span><br><span class="line">                while(curr.left != null &amp;&amp; curr.left.val &lt; low){</span><br><span class="line">                    curr.left = curr.left.right;</span><br><span class="line">                }</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            }</span><br><span class="line">            //go back to root;</span><br><span class="line">            curr = root;</span><br><span class="line"></span><br><span class="line">            //deal with root's righg sub-tree, and deal with the value bigger than high.</span><br><span class="line">            while(curr != null){</span><br><span class="line">                while(curr.right != null &amp;&amp; curr.right.val &gt; high){</span><br><span class="line">                    curr.right = curr.right.left;</span><br><span class="line">                }</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            }</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="将有序数组转换为二叉搜索树：LK108"><a href="#将有序数组转换为二叉搜索树：LK108" class="headerlink" title="将有序数组转换为二叉搜索树：LK108"></a>将有序数组转换为二叉搜索树：LK108</h2><h3 id="思路：寻找分割点，分割点作为当前节点，然后递归左区间和右区间。"><a href="#思路：寻找分割点，分割点作为当前节点，然后递归左区间和右区间。" class="headerlink" title="思路：寻找分割点，分割点作为当前节点，然后递归左区间和右区间。"></a>思路：<strong>寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK108 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val, TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) {</span><br><span class="line">        if (nums.length == 0) {</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        //根节点初始化</span><br><span class="line">        TreeNode root = new TreeNode(-1);</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; leftQueue = new LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; rightQueue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 根节点入队列</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        // 0为左区间下标初始位置</span><br><span class="line">        leftQueue.offer(0);</span><br><span class="line">        // nums.size() - 1为右区间下标初始位置</span><br><span class="line">        rightQueue.offer(nums.length - 1);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.isEmpty()) {</span><br><span class="line">            TreeNode currNode = nodeQueue.poll();</span><br><span class="line">            int left = leftQueue.poll();</span><br><span class="line">            int right = rightQueue.poll();</span><br><span class="line">            int mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line"></span><br><span class="line">            // 将mid对应的元素给中间节点</span><br><span class="line">            currNode.val = nums[mid];</span><br><span class="line"></span><br><span class="line">            // 处理左区间</span><br><span class="line">            if (left &lt;= mid - 1) {</span><br><span class="line">                currNode.left = new TreeNode(-1);</span><br><span class="line">                nodeQueue.offer(currNode.left);</span><br><span class="line">                leftQueue.offer(left);</span><br><span class="line">                rightQueue.offer(mid - 1);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // 处理右区间</span><br><span class="line">            if (right &gt;= mid + 1) {</span><br><span class="line">                currNode.right = new TreeNode(-1);</span><br><span class="line">                nodeQueue.offer(currNode.right);</span><br><span class="line">                leftQueue.offer(mid + 1);</span><br><span class="line">                rightQueue.offer(right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法代码："><a href="#其他方法代码：" class="headerlink" title="其他方法代码："></a>其他方法代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> {</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[left]);</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sortedArrayToBST(nums, left, mid);</span><br><span class="line">        root.right = sortedArrayToBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="把二叉搜索树转换为累加树：LK538"><a href="#把二叉搜索树转换为累加树：LK538" class="headerlink" title="把二叉搜索树转换为累加树：LK538"></a>把二叉搜索树转换为累加树：LK538</h2><h3 id="思路：按右中左顺序遍历累加即可"><a href="#思路：按右中左顺序遍历累加即可" class="headerlink" title="思路：按右中左顺序遍历累加即可"></a>思路：按右中左顺序遍历累加即可</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class LK538 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int sum;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) {</span><br><span class="line"></span><br><span class="line">            sum = 0;</span><br><span class="line">            convertBST1(root);</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 按右中左顺序遍历，累加即可</span><br><span class="line">        public void convertBST1(TreeNode root) {</span><br><span class="line">            if (root == null) {</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">            convertBST1(root.right);</span><br><span class="line">            sum += root.val;</span><br><span class="line">            root.val = sum;</span><br><span class="line">            convertBST1(root.left);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;修剪二叉搜索树：LK669&quot;&gt;&lt;a href=&quot;#修剪二叉搜索树：LK669&quot; class=&quot;headerlink&quot; title=&quot;修剪二叉搜索树：LK669&quot;&gt;&lt;/a&gt;修剪二叉搜索树：LK669&lt;/h2&gt;&lt;h3 id=&quot;思路：和删除二叉搜索树差不多，只是多了一个</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>day018</title>
    <link href="https://cyc199811.github.io/2024/05/09/day23/"/>
    <id>https://cyc199811.github.io/2024/05/09/day23/</id>
    <published>2024-05-09T10:19:05.075Z</published>
    <updated>2024-05-13T01:37:37.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树搜索树的最小绝对差：LK530"><a href="#二叉树搜索树的最小绝对差：LK530" class="headerlink" title="二叉树搜索树的最小绝对差：LK530"></a>二叉树搜索树的最小绝对差：LK530</h2><h3 id="思路：运用递归或者迭代遍历记录前后两个节点的最小差值"><a href="#思路：运用递归或者迭代遍历记录前后两个节点的最小差值" class="headerlink" title="思路：运用递归或者迭代遍历记录前后两个节点的最小差值"></a>思路：运用递归或者迭代遍历记录前后两个节点的最小差值</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class LK530 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public int getMinimumDifference(TreeNode root) {</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = null;</span><br><span class="line">        int result = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        if(root != null)</span><br><span class="line">            stack.add(root);</span><br><span class="line">        while(!stack.isEmpty()){</span><br><span class="line">            TreeNode curr = stack.peek();</span><br><span class="line">            if(curr != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if(curr.right != null)</span><br><span class="line">                    stack.add(curr.right);</span><br><span class="line">                stack.add(curr);</span><br><span class="line">                stack.add(null);//为后面的条件计算服务pre</span><br><span class="line">                if(curr.left != null)</span><br><span class="line">                    stack.add(curr.left);</span><br><span class="line">            }else{</span><br><span class="line">                stack.pop();</span><br><span class="line">                TreeNode temp = stack.pop();</span><br><span class="line">                if(pre != null)</span><br><span class="line">                    result = Math.min(result, temp.val - pre.val);</span><br><span class="line">                pre = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    TreeNode pre;// 记录上一个遍历的结点</span><br><span class="line">    int result = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference2(TreeNode root) {</span><br><span class="line">        if(root==null)return 0;</span><br><span class="line">        traversal(root);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public void traversal(TreeNode root){</span><br><span class="line">        if(root==null)return;</span><br><span class="line">        //左</span><br><span class="line">        traversal(root.left);</span><br><span class="line">        //中</span><br><span class="line">        if(pre!=null){</span><br><span class="line">            result = Math.min(result,root.val-pre.val);</span><br><span class="line">        }</span><br><span class="line">        pre = root;</span><br><span class="line">        //右</span><br><span class="line">        traversal(root.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉搜索树中的众数：LK501"><a href="#二叉搜索树中的众数：LK501" class="headerlink" title="二叉搜索树中的众数：LK501"></a>二叉搜索树中的众数：LK501</h2><h3 id="思路：遍历二叉树记录其中的众数"><a href="#思路：遍历二叉树记录其中的众数" class="headerlink" title="思路：遍历二叉树记录其中的众数"></a>思路：遍历二叉树记录其中的众数</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class LK501 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ArrayList&lt;Integer&gt; resList;</span><br><span class="line">    int maxCount;</span><br><span class="line">    int count;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    public int[] findMode(TreeNode root) {</span><br><span class="line">            resList = new ArrayList&lt;&gt;();</span><br><span class="line">            maxCount = 0;</span><br><span class="line">            count = 0;</span><br><span class="line">            pre = null;</span><br><span class="line">            findMode1(root);</span><br><span class="line">            int[] res = new int[resList.size()];</span><br><span class="line">            for (int i = 0; i &lt; resList.size(); i++) {</span><br><span class="line">                res[i] = resList.get(i);</span><br><span class="line">            }</span><br><span class="line">            return res;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public void findMode1(TreeNode root) {</span><br><span class="line">            if (root == null) {</span><br><span class="line">                return;</span><br><span class="line">            }</span><br><span class="line">            findMode1(root.left);</span><br><span class="line"></span><br><span class="line">            int rootValue = root.val;</span><br><span class="line">            // 计数</span><br><span class="line">            if (pre == null || rootValue != pre.val) {</span><br><span class="line">                count = 1;</span><br><span class="line">            } else {</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            // 更新结果以及maxCount</span><br><span class="line">            if (count &gt; maxCount) {</span><br><span class="line">                resList.clear();</span><br><span class="line">                resList.add(rootValue);</span><br><span class="line">                maxCount = count;</span><br><span class="line">            } else if (count == maxCount) {</span><br><span class="line">                resList.add(rootValue);</span><br><span class="line">            }</span><br><span class="line">            pre = root;</span><br><span class="line"></span><br><span class="line">            findMode1(root.right);</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的最近公共祖先：LK236"><a href="#二叉树的最近公共祖先：LK236" class="headerlink" title="二叉树的最近公共祖先：LK236"></a>二叉树的最近公共祖先：LK236</h2><h3 id="思路：用二叉树的后序遍历，再由回溯算法由下向上搜索"><a href="#思路：用二叉树的后序遍历，再由回溯算法由下向上搜索" class="headerlink" title="思路：用二叉树的后序遍历，再由回溯算法由下向上搜索"></a>思路：用二叉树的后序遍历，再由回溯算法由下向上搜索</h3><img src="/2024/05/09/day23/image-20240509190750075.png" alt="image-20240509190750075" style="zoom:200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK236 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //后序遍历，利用它的回溯法</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</span><br><span class="line">        if (root == null || root == p || root == q){</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        if (left == null &amp;&amp; right == null){</span><br><span class="line">            return null;</span><br><span class="line">        } else if (left == null &amp;&amp; right != null) {</span><br><span class="line">            return right;</span><br><span class="line">        } else if (left != null &amp;&amp; right == null) {</span><br><span class="line">            return left;</span><br><span class="line">        }else {</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树搜索树的最小绝对差：LK530&quot;&gt;&lt;a href=&quot;#二叉树搜索树的最小绝对差：LK530&quot; class=&quot;headerlink&quot; title=&quot;二叉树搜索树的最小绝对差：LK530&quot;&gt;&lt;/a&gt;二叉树搜索树的最小绝对差：LK530&lt;/h2&gt;&lt;h3 id=&quot;思</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>day017</title>
    <link href="https://cyc199811.github.io/2024/05/08/day22/"/>
    <id>https://cyc199811.github.io/2024/05/08/day22/</id>
    <published>2024-05-08T11:40:52.686Z</published>
    <updated>2024-05-13T01:37:46.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最大二叉树：LK654"><a href="#最大二叉树：LK654" class="headerlink" title="最大二叉树：LK654"></a>最大二叉树：LK654</h2><h3 id="思路：找到最大值然后划分数组递归划分创建节点就行"><a href="#思路：找到最大值然后划分数组递归划分创建节点就行" class="headerlink" title="思路：找到最大值然后划分数组递归划分创建节点就行"></a>思路：找到最大值然后划分数组递归划分创建节点就行</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class LK654 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) {</span><br><span class="line">       return buildHelper(nums, 0, nums.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode buildHelper(int[] nums, int leftIndex, int rightIndex){</span><br><span class="line">        if (rightIndex -  leftIndex &lt;1){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        if (rightIndex -  leftIndex == 1){</span><br><span class="line">            return new TreeNode(nums[leftIndex]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //找到最大元素分割数组</span><br><span class="line">        int maxIndex = leftIndex;// 最大值所在位置</span><br><span class="line">        int maxValue = nums[maxIndex];// 最大值</span><br><span class="line">        for (int i = leftIndex + 1; i &lt; rightIndex; i++) {</span><br><span class="line">            if (nums[i] &gt; maxValue){</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //根据最大元素构造根节点（中）</span><br><span class="line">        TreeNode root = new TreeNode(maxValue);</span><br><span class="line"></span><br><span class="line">        //向左递归构造左子树</span><br><span class="line">        root.left = buildHelper(nums, leftIndex, maxIndex);</span><br><span class="line"></span><br><span class="line">        //向右递归构造右子树</span><br><span class="line">        root.right = buildHelper(nums, maxIndex + 1, rightIndex);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="合并二叉树：LK617"><a href="#合并二叉树：LK617" class="headerlink" title="合并二叉树：LK617"></a>合并二叉树：LK617</h2><h3 id="思路：递归将两棵树的相同位置的节点值相加构建新节点"><a href="#思路：递归将两棵树的相同位置的节点值相加构建新节点" class="headerlink" title="思路：递归将两棵树的相同位置的节点值相加构建新节点"></a>思路：递归将两棵树的相同位置的节点值相加构建新节点</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK617 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {</span><br><span class="line">        return merge(root1, root2);</span><br><span class="line">    }</span><br><span class="line">    public TreeNode merge(TreeNode left, TreeNode right){</span><br><span class="line">        if (left == null &amp;&amp; right == null){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        if (left == null){</span><br><span class="line">            return right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (right == null){</span><br><span class="line">            return left;</span><br><span class="line">        }</span><br><span class="line">        TreeNode root = new TreeNode(left.val + right.val);</span><br><span class="line">        root.left = merge(left.left  , right.left);</span><br><span class="line">        root.right = merge(left.right, right.right);</span><br><span class="line">        return  root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉搜索树中的搜索：LK700"><a href="#二叉搜索树中的搜索：LK700" class="headerlink" title="二叉搜索树中的搜索：LK700"></a>二叉搜索树中的搜索：LK700</h2><h3 id="思路：使用遍历进行值的匹配就行，相等就返回节点"><a href="#思路：使用遍历进行值的匹配就行，相等就返回节点" class="headerlink" title="思路：使用遍历进行值的匹配就行，相等就返回节点"></a>思路：使用遍历进行值的匹配就行，相等就返回节点</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class Lk700 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) {</span><br><span class="line">        if (root == null || root.val == val) {</span><br><span class="line">            return root;</span><br><span class="line">        }</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (!queue.isEmpty()) {</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.val == val) {</span><br><span class="line">                return node;</span><br><span class="line">            }</span><br><span class="line">            if (node.right != null) {</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">            if (node.left != null) {</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return null;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="验证二叉搜索树：LK98"><a href="#验证二叉搜索树：LK98" class="headerlink" title="验证二叉搜索树：LK98"></a>验证二叉搜索树：LK98</h2><h3 id="思路：验证每个节点左边节点的值小于该节点，该节点的值小于右边节点的值"><a href="#思路：验证每个节点左边节点的值小于该节点，该节点的值小于右边节点的值" class="headerlink" title="思路：验证每个节点左边节点的值小于该节点，该节点的值小于右边节点的值"></a>思路：验证每个节点左边节点的值小于该节点，该节点的值小于右边节点的值</h3><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class LK098 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    // 递归</span><br><span class="line">    TreeNode max;</span><br><span class="line">    public boolean isValidBST(TreeNode root) {</span><br><span class="line">        if (root == null) {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">        // 左</span><br><span class="line">        boolean left = isValidBST(root.left);</span><br><span class="line">        if (!left) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        // 中if (max != null &amp;&amp; root.val &lt;= max.val) { return false; }: 如果当前节点的值小于等于已经遍历过的最大值 max 的值，</span><br><span class="line">        // 则不满足 BST 的条件，直接返回 false</span><br><span class="line">        //max = root;: 更新 max 为当前节点，因为当前节点符合 BST 的条件。</span><br><span class="line">        if (max != null &amp;&amp; root.val &lt;= max.val) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        max = root;//记录前一个节点</span><br><span class="line">        // 右</span><br><span class="line">        boolean right = isValidBST(root.right);</span><br><span class="line">        return right;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">//使用統一迭代法</span><br><span class="line">class Solution {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isValidBST(TreeNode root) {</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = null;</span><br><span class="line">        if(root != null)</span><br><span class="line">            stack.add(root);</span><br><span class="line">        while(!stack.isEmpty()){</span><br><span class="line">            TreeNode curr = stack.peek();</span><br><span class="line">            if(curr != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if(curr.right != null)</span><br><span class="line">                    stack.add(curr.right);</span><br><span class="line">                stack.add(curr);</span><br><span class="line">                stack.add(null);</span><br><span class="line">                if(curr.left != null)</span><br><span class="line">                    stack.add(curr.left);</span><br><span class="line">            }else{</span><br><span class="line">                stack.pop();</span><br><span class="line">                TreeNode temp = stack.pop();</span><br><span class="line">                if(pre != null &amp;&amp; pre.val &gt;= temp.val)</span><br><span class="line">                    return false;</span><br><span class="line">                pre = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法代码："><a href="#其他方法代码：" class="headerlink" title="其他方法代码："></a>其他方法代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)</span><br><span class="line">            stack.add(root);        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(curr != <span class="literal">null</span>){</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(curr.right != <span class="literal">null</span>)</span><br><span class="line">                    stack.add(curr.right);</span><br><span class="line">                stack.add(curr);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span>(curr.left != <span class="literal">null</span>)</span><br><span class="line">                    stack.add(curr.left);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= temp.val)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最大二叉树：LK654&quot;&gt;&lt;a href=&quot;#最大二叉树：LK654&quot; class=&quot;headerlink&quot; title=&quot;最大二叉树：LK654&quot;&gt;&lt;/a&gt;最大二叉树：LK654&lt;/h2&gt;&lt;h3 id=&quot;思路：找到最大值然后划分数组递归划分创建节点就行&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>day016</title>
    <link href="https://cyc199811.github.io/2024/05/07/day21/"/>
    <id>https://cyc199811.github.io/2024/05/07/day21/</id>
    <published>2024-05-07T08:08:39.886Z</published>
    <updated>2024-05-13T01:37:55.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="找树左下角的值：LK513"><a href="#找树左下角的值：LK513" class="headerlink" title="找树左下角的值：LK513"></a>找树左下角的值：LK513</h2><h3 id="思路：记录每一个做子叶节点的值，最后一个就是左下角的值"><a href="#思路：记录每一个做子叶节点的值，最后一个就是左下角的值" class="headerlink" title="思路：记录每一个做子叶节点的值，最后一个就是左下角的值"></a>思路：记录每一个做子叶节点的值，最后一个就是左下角的值</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK513 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) {</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            int res = 0;</span><br><span class="line">            while (!queue.isEmpty()) {</span><br><span class="line">                int size = queue.size();</span><br><span class="line">                for (int i = 0; i &lt; size; i++) {</span><br><span class="line">                    TreeNode poll = queue.poll();</span><br><span class="line">                    if (i == 0) {</span><br><span class="line">                        res = poll.val;</span><br><span class="line">                    }</span><br><span class="line">                    if (poll.left != null) {</span><br><span class="line">                        queue.offer(poll.left);</span><br><span class="line">                    }</span><br><span class="line">                    if (poll.right != null) {</span><br><span class="line">                        queue.offer(poll.right);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            return res;</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="路径总和：LK112"><a href="#路径总和：LK112" class="headerlink" title="路径总和：LK112"></a>路径总和：LK112</h2><h3 id="思路：递归遍历每一条路径，并计算路径上的节点的值总和，等于sum-就返回-true"><a href="#思路：递归遍历每一条路径，并计算路径上的节点的值总和，等于sum-就返回-true" class="headerlink" title="思路：递归遍历每一条路径，并计算路径上的节点的值总和，等于sum 就返回 true"></a>思路：递归遍历每一条路径，并计算路径上的节点的值总和，等于sum 就返回 true</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK112 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">    if (root.left ==null &amp;&amp; root.right == null){</span><br><span class="line">        return targetSum == 0;</span><br><span class="line">    }</span><br><span class="line">    if (root.left != null){</span><br><span class="line">        boolean left = hasPathSum(root.left, targetSum);</span><br><span class="line">        if (left == true){</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (root.right != null){</span><br><span class="line">        boolean right = hasPathSum(root.right, targetSum);</span><br><span class="line">        if (right == true){</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="从中序与后序遍历序列构造二叉树：LK106"><a href="#从中序与后序遍历序列构造二叉树：LK106" class="headerlink" title="从中序与后序遍历序列构造二叉树：LK106"></a>从中序与后序遍历序列构造二叉树：LK106</h1><h3 id="思路：后序遍历确定根节点"><a href="#思路：后序遍历确定根节点" class="headerlink" title="思路：后序遍历确定根节点"></a>思路：后序遍历确定根节点</h3><h3 id="根据根节点划分中序数组的左右子树"><a href="#根据根节点划分中序数组的左右子树" class="headerlink" title="根据根节点划分中序数组的左右子树"></a>根据根节点划分中序数组的左右子树</h3><img src="/2024/05/07/day21/image-20240507162748144.png" alt="image-20240507162748144" style="zoom: 200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class LK106 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) {</span><br><span class="line">        if (inorder.length == 0 || postorder.length == 0){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        return buildHelper(inorder, 0, inorder.length, postorder, 0, postorder.length);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode buildHelper(int[] inorder, int inorderStart, int inorderEnd,</span><br><span class="line">                                int[] postorder, int postorderStart, int postorderEnd){</span><br><span class="line">        if (postorderStart == postorderEnd){return null;}</span><br><span class="line">        //找到后序数组的最后一个数确定根元素</span><br><span class="line">        int rootVal = postorder[postorderEnd - 1];</span><br><span class="line">        //构造根节点</span><br><span class="line">        TreeNode root = new TreeNode(rootVal);</span><br><span class="line">        //根据根节点划分中序数组的左右子数组</span><br><span class="line">        int middleIndex;</span><br><span class="line">        for (middleIndex = inorderStart; middleIndex &lt; inorderEnd; middleIndex ++){</span><br><span class="line">            if (inorder[middleIndex] == rootVal){break;}</span><br><span class="line">        }</span><br><span class="line">        //中序数组划分</span><br><span class="line">        int leftInorderStart = inorderStart;//</span><br><span class="line">        int leftInorderEnd = middleIndex;//</span><br><span class="line"></span><br><span class="line">        int rightInorderStart = middleIndex + 1;//</span><br><span class="line">        int rightInorderEnd = inorderEnd;</span><br><span class="line">        //后序数组划分</span><br><span class="line">        int leftPostorderStart = postorderStart;</span><br><span class="line">        int leftPostorderEnd = postorderStart + (middleIndex - inorderStart);//important</span><br><span class="line">        int rightPostorderStart = leftPostorderEnd;</span><br><span class="line">        int rightPostorderEnd = postorderEnd - 1;//除去根节点</span><br><span class="line"></span><br><span class="line">        root.left = buildHelper(inorder, leftInorderStart, leftInorderEnd,  postorder, leftPostorderStart, leftPostorderEnd);</span><br><span class="line">        root.right = buildHelper(inorder, rightInorderStart, rightInorderEnd, postorder, rightPostorderStart, rightPostorderEnd);</span><br><span class="line"></span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;找树左下角的值：LK513&quot;&gt;&lt;a href=&quot;#找树左下角的值：LK513&quot; class=&quot;headerlink&quot; title=&quot;找树左下角的值：LK513&quot;&gt;&lt;/a&gt;找树左下角的值：LK513&lt;/h2&gt;&lt;h3 id=&quot;思路：记录每一个做子叶节点的值，最后一个就</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>卖股票的最佳时机</title>
    <link href="https://cyc199811.github.io/2024/05/06/%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://cyc199811.github.io/2024/05/06/%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2024-05-06T13:44:31.194Z</published>
    <updated>2024-05-07T08:08:31.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卖股票的最佳时机1：LK121"><a href="#卖股票的最佳时机1：LK121" class="headerlink" title="卖股票的最佳时机1：LK121"></a>卖股票的最佳时机1：LK121</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><h3 id="dp-i-0-代表第i天持有股票的最大收益；"><a href="#dp-i-0-代表第i天持有股票的最大收益；" class="headerlink" title="dp[i][0]代表第i天持有股票的最大收益；"></a>dp[i][0]代表第i天持有股票的最大收益；</h3><h3 id="dp-i-1-代表第i天不持有股票的最大收益"><a href="#dp-i-1-代表第i天不持有股票的最大收益" class="headerlink" title="dp[i][1]代表第i天不持有股票的最大收益"></a>dp[i][1]代表第i天不持有股票的最大收益</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK121 {</span><br><span class="line">    public int maxProfit(int[] prices) {</span><br><span class="line">        if (prices == null || prices.length == 0) return 0;</span><br><span class="line">        int length = prices.length;</span><br><span class="line">        </span><br><span class="line">        int[][] dp = new int[length][2];</span><br><span class="line">        dp[0][0] = -prices[0];</span><br><span class="line">        dp[0][1] = 0;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) {</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);</span><br><span class="line">        }</span><br><span class="line">        return dp[length - 1][1];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="卖股票的最佳时机2：LK122"><a href="#卖股票的最佳时机2：LK122" class="headerlink" title="卖股票的最佳时机2：LK122"></a>卖股票的最佳时机2：LK122</h2><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><h3 id="dp-i-0-代表第i天持有股票的最大收益；-1"><a href="#dp-i-0-代表第i天持有股票的最大收益；-1" class="headerlink" title="dp[i][0]代表第i天持有股票的最大收益；"></a>dp[i][0]代表第i天持有股票的最大收益；</h3><h3 id="dp-i-1-代表第i天不持有股票的最大收益-1"><a href="#dp-i-1-代表第i天不持有股票的最大收益-1" class="headerlink" title="dp[i][1]代表第i天不持有股票的最大收益"></a>dp[i][1]代表第i天不持有股票的最大收益</h3><h3 id="如果第i天持有股票即dp-i-0-，-那么可以由两个状态推出来"><a href="#如果第i天持有股票即dp-i-0-，-那么可以由两个状态推出来" class="headerlink" title="如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来"></a>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</h3><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK122 {</span><br><span class="line">    public int maxProfit(int[] prices) {</span><br><span class="line">        int n = prices.length;</span><br><span class="line">        int[][] dp = new int[n][2];</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) {</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);</span><br><span class="line">        }</span><br><span class="line">        return dp[n - 1][0];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="卖股票的最佳时机3：LK123"><a href="#卖股票的最佳时机3：LK123" class="headerlink" title="卖股票的最佳时机3：LK123"></a>卖股票的最佳时机3：LK123</h2><h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><ol><li>确定dp数组以及下标的含义</li></ol><p>一天一共就有五个状态，</p><ol><li>没有操作 （其实我们也可以不设置这个状态）</li><li>第一次持有股票</li><li>第一次不持有股票</li><li>第二次持有股票</li><li>第二次不持有股票</li></ol><p>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</p><img src="/2024/05/06/%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/image-20240506222809881.png" alt="image-20240506222809881" style="zoom: 200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK123 {</span><br><span class="line">    public int maxProfit(int[] prices) {</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        // 边界判断, 题目中 length &gt;= 1, 所以可省去</span><br><span class="line">        if (prices.length == 0) return 0;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 定义 5 种状态:</span><br><span class="line">         * 0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出</span><br><span class="line">         */</span><br><span class="line">        int[][] dp = new int[len][5];</span><br><span class="line">        dp[0][0] = 0;</span><br><span class="line">        dp[0][1] = -prices[0];</span><br><span class="line">        dp[0][2] = 0;</span><br><span class="line">        // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润</span><br><span class="line">        dp[0][3] = -prices[0];</span><br><span class="line">dp[0][4] = 0;</span><br><span class="line">        for (int i = 1; i &lt; len; i++) {</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);</span><br><span class="line">            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);</span><br><span class="line">            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</span><br><span class="line">            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        return dp[len - 1][4];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="卖股票的最佳时机4：LK188"><a href="#卖股票的最佳时机4：LK188" class="headerlink" title="卖股票的最佳时机4：LK188"></a>卖股票的最佳时机4：LK188</h2><h3 id="思路：和3差不多只是状态多了需要用循环来进行初始化"><a href="#思路：和3差不多只是状态多了需要用循环来进行初始化" class="headerlink" title="思路：和3差不多只是状态多了需要用循环来进行初始化"></a>思路：和3差不多只是状态多了需要用循环来进行初始化</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li>确定dp数组以及下标的含义</li></ol><p>一天一共就有 2 * k  + 1个状态，</p><ol><li><p>没有操作 （其实我们也可以不设置这个状态）</p></li><li><p>第一次持有股票</p></li><li><p>第一次不持有股票</p></li><li><p>第二次持有股票</p></li><li><p>第二次不持有股票</p><p>. </p><p>.</p><p>.</p><p>.</p><p>.</p><p>.</p></li></ol><h3 id="其中奇数为持有股票状态"><a href="#其中奇数为持有股票状态" class="headerlink" title="其中奇数为持有股票状态"></a>其中奇数为持有股票状态</h3><h3 id="偶数为卖出股票状态"><a href="#偶数为卖出股票状态" class="headerlink" title="偶数为卖出股票状态"></a>偶数为卖出股票状态</h3><h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK188 {</span><br><span class="line">       public int maxProfit(int k, int[] prices) {</span><br><span class="line">        if (prices.length == 0) return 0;</span><br><span class="line"></span><br><span class="line">        // [天数][股票状态]</span><br><span class="line">        // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作</span><br><span class="line">        int len = prices.length;</span><br><span class="line">        int[][] dp = new int[len][k*2 + 1];</span><br><span class="line">        dp[0][0] = 0; </span><br><span class="line">        // dp数组的初始化, 与版本一同理</span><br><span class="line">        for (int i = 1; i &lt; k*2; i += 2) {</span><br><span class="line">            dp[0][i] = -prices[0];</span><br><span class="line">            dp[0][i + 1] = 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; len; i++) {</span><br><span class="line">            for (int j = 0; j &lt; k*2 - 1; j += 2) {</span><br><span class="line">                dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);</span><br><span class="line">                dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return dp[len - 1][k*2];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="最佳买卖股票时机含冷冻期-LK309"><a href="#最佳买卖股票时机含冷冻期-LK309" class="headerlink" title="最佳买卖股票时机含冷冻期:LK309"></a>最佳买卖股票时机含冷冻期:LK309</h1><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><img src="/2024/05/06/%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/image-20240507103402392.png" alt="image-20240507103402392" style="zoom:150%;"><h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK309 {</span><br><span class="line">    public int maxProfit(int[] prices) {</span><br><span class="line">        int[][] dp = new int[prices.length + 1][2];</span><br><span class="line">        dp[1][0] = -prices[0];</span><br><span class="line"></span><br><span class="line">        for (int i = 2; i &lt;= prices.length; i++) {</span><br><span class="line">            /*</span><br><span class="line">            dp[i][0] 第i天持有股票收益;</span><br><span class="line">            dp[i][1] 第i天不持有股票收益;</span><br><span class="line">            情况一：第i天是冷静期，不能以dp[i-1][1]购买股票,所以以dp[i - 2][1]买股票，没问题</span><br><span class="line">            情况二：第i天不是冷静期，理论上应该以dp[i-1][1]购买股票，但是第i天不是冷静期说明，第i-1天没有卖出股票，</span><br><span class="line">                则dp[i-1][1]=dp[i-2][1],所以可以用dp[i-2][1]买股票，没问题</span><br><span class="line">             */</span><br><span class="line">            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 2][1] - prices[i - 1]);</span><br><span class="line">            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i - 1]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return dp[prices.length][1];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;卖股票的最佳时机1：LK121&quot;&gt;&lt;a href=&quot;#卖股票的最佳时机1：LK121&quot; class=&quot;headerlink&quot; title=&quot;卖股票的最佳时机1：LK121&quot;&gt;&lt;/a&gt;卖股票的最佳时机1：LK121&lt;/h2&gt;&lt;h3 id=&quot;思路：&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="动态规划" scheme="https://cyc199811.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="https://cyc199811.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>day014</title>
    <link href="https://cyc199811.github.io/2024/05/05/day19/"/>
    <id>https://cyc199811.github.io/2024/05/05/day19/</id>
    <published>2024-05-05T04:43:15.000Z</published>
    <updated>2024-05-13T01:38:10.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的最大深度：LK104"><a href="#二叉树的最大深度：LK104" class="headerlink" title="二叉树的最大深度：LK104"></a>二叉树的最大深度：LK104</h2><h3 id="思路：用层序遍历在每层记录层数就行"><a href="#思路：用层序遍历在每层记录层数就行" class="headerlink" title="思路：用层序遍历在每层记录层数就行"></a>思路：用层序遍历在每层记录层数就行</h3><img src="/2024/05/05/day19/image-20240505153756937.png" alt="image-20240505153756937" style="zoom:200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK104 {</span><br><span class="line"></span><br><span class="line"> public class TreeNode {</span><br><span class="line">  int val;</span><br><span class="line">  TreeNode left;</span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode() {</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  TreeNode(int val) {</span><br><span class="line">   this.val = val;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">   this.val = val;</span><br><span class="line">   this.left = left;</span><br><span class="line">   this.right = right;</span><br><span class="line">  }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> public int maxDepth(TreeNode root) {</span><br><span class="line">  if (root == null) {</span><br><span class="line">   return 0;</span><br><span class="line">  }</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">  //队列先进先出</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  int maxDepth = 0;</span><br><span class="line">  while (!queue.isEmpty()) {</span><br><span class="line">   int currentLevelSize = queue.size();</span><br><span class="line">   while (currentLevelSize &gt; 0){</span><br><span class="line">    TreeNode node = queue.poll();</span><br><span class="line">    if (node.left != null) {</span><br><span class="line">     queue.offer(node.left);</span><br><span class="line">    }</span><br><span class="line">    if (node.right != null) {</span><br><span class="line">     queue.offer(node.right);</span><br><span class="line">    }</span><br><span class="line">    currentLevelSize --;</span><br><span class="line">   }</span><br><span class="line">   maxDepth++;</span><br><span class="line">  }</span><br><span class="line">  return maxDepth;</span><br><span class="line"> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的最小深度：LK111"><a href="#二叉树的最小深度：LK111" class="headerlink" title="二叉树的最小深度：LK111"></a>二叉树的最小深度：LK111</h2><h3 id="思路：运用层序遍历，当遇到节点的左右孩子节点为-null-的时候记录最小深度"><a href="#思路：运用层序遍历，当遇到节点的左右孩子节点为-null-的时候记录最小深度" class="headerlink" title="思路：运用层序遍历，当遇到节点的左右孩子节点为 null 的时候记录最小深度"></a>思路：运用层序遍历，当遇到节点的左右孩子节点为 null 的时候记录最小深度</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK111 {</span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">       TreeNode left;</span><br><span class="line">       TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int minDepth(TreeNode root) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        int depth = 0;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (! queue.isEmpty()){</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            depth ++;</span><br><span class="line">            for (int i = 0; i &lt; size; i++) {</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                if (cur.left == null &amp;&amp; cur.right == null){</span><br><span class="line">                    return depth;</span><br><span class="line">                }</span><br><span class="line">                if (cur.right != null){</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                }</span><br><span class="line">                if (cur.left != null){</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return depth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="完全二叉树的节点个数：LK222"><a href="#完全二叉树的节点个数：LK222" class="headerlink" title="完全二叉树的节点个数：LK222"></a>完全二叉树的节点个数：LK222</h2><h3 id="思路：计算左边和右边的节点数最后加上根节点"><a href="#思路：计算左边和右边的节点数最后加上根节点" class="headerlink" title="思路：计算左边和右边的节点数最后加上根节点"></a>思路：计算左边和右边的节点数最后加上根节点</h3><img src="/2024/05/05/day19/image-20240505154740562.png" alt="image-20240505154740562" style="zoom:200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK222 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public int countNodes(TreeNode root) {</span><br><span class="line">        if(root == null) {</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        return countNodes(root.left) + countNodes(root.right) + 1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的最大深度：LK104&quot;&gt;&lt;a href=&quot;#二叉树的最大深度：LK104&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度：LK104&quot;&gt;&lt;/a&gt;二叉树的最大深度：LK104&lt;/h2&gt;&lt;h3 id=&quot;思路：用层序遍历在每层记录层数就行</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>day015</title>
    <link href="https://cyc199811.github.io/2024/05/05/day20/"/>
    <id>https://cyc199811.github.io/2024/05/05/day20/</id>
    <published>2024-05-05T04:43:15.000Z</published>
    <updated>2024-05-13T01:38:02.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平衡二叉树：LK110"><a href="#平衡二叉树：LK110" class="headerlink" title="平衡二叉树：LK110"></a>平衡二叉树：LK110</h2><h3 id="思路：用层序遍历，求取根节点的左右子树的层数差-小于等于1！"><a href="#思路：用层序遍历，求取根节点的左右子树的层数差-小于等于1！" class="headerlink" title="思路：用层序遍历，求取根节点的左右子树的层数差 小于等于1！"></a>思路：用层序遍历，求取根节点的左右子树的层数差 小于等于1！</h3><img src="/2024/05/05/day20/image-20240506170208247.png" alt="image-20240506170208247" style="zoom:200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK110 {</span><br><span class="line">    class TreeNode {</span><br><span class="line">        TreeNode left;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public boolean isBalanced(TreeNode root) {</span><br><span class="line">        int gap = max(root) - min(root);</span><br><span class="line">        return gap == 0 || gap == 1;</span><br><span class="line">    }</span><br><span class="line">    public int min(TreeNode root) {</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">       // int maxDepth = 0;</span><br><span class="line">        int minDepth = 1;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while ( ! queue.isEmpty()){</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) {</span><br><span class="line">                //maxDepth ++;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                }</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                }</span><br><span class="line">                if (node.left == null &amp;&amp; node.right == null){</span><br><span class="line">                    return minDepth;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return minDepth;</span><br><span class="line">    }</span><br><span class="line">    public int max(TreeNode root) {</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        int maxDepth = 1;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while ( ! queue.isEmpty()){</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) {</span><br><span class="line">                maxDepth ++;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                }</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return maxDepth;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法代码："><a href="#其他方法代码：" class="headerlink" title="其他方法代码："></a>其他方法代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == -<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 左右子树高度差大于1，return -1表示已经不是平衡树了</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的所有路径：LK257"><a href="#二叉树的所有路径：LK257" class="headerlink" title="二叉树的所有路径：LK257"></a>二叉树的所有路径：LK257</h2><h3 id="思路：运用回溯算法暴力求解"><a href="#思路：运用回溯算法暴力求解" class="headerlink" title="思路：运用回溯算法暴力求解"></a>思路：运用回溯算法暴力求解</h3><img src="/2024/05/05/day20/image-20240506170937396.png" alt="image-20240506170937396" style="zoom:200%;"><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class LK257 {   static class TreeNode {</span><br><span class="line">    TreeNode left;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode(int i) {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">    LK257 lk257 = new LK257();</span><br><span class="line">    TreeNode root = new TreeNode(1);</span><br><span class="line">    TreeNode node2 = new TreeNode(2);</span><br><span class="line">    TreeNode node3 = new TreeNode(3);</span><br><span class="line">    TreeNode node4 = new TreeNode(4);</span><br><span class="line">    TreeNode node5 = new TreeNode(5);</span><br><span class="line"></span><br><span class="line">    // 构建二叉树结构</span><br><span class="line">    root.left = node2;</span><br><span class="line">    root.right = node3;</span><br><span class="line">    node2.left = node4;</span><br><span class="line">    node2.right = node5;</span><br><span class="line">    lk257.binaryTreePaths(root);</span><br><span class="line">}</span><br><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) {</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();// 存最终的结果</span><br><span class="line">    if (root == null) {</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line">    List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// 作为结果中的路径</span><br><span class="line">    traversal(root, paths, res);</span><br><span class="line">    return res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) {</span><br><span class="line">        paths.add(root.val);// 前序遍历，中</span><br><span class="line">        // 遇到叶子结点</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null) {</span><br><span class="line">            // 输出</span><br><span class="line">            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快</span><br><span class="line">            for (int i = 0; i &lt; paths.size() - 1; i++) {</span><br><span class="line">                sb.append(paths.get(i)).append("-&gt;");</span><br><span class="line">                System.out.println(res);</span><br><span class="line">            }</span><br><span class="line">            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点</span><br><span class="line">            res.add(sb.toString());// 收集一个路径</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        // 递归和回溯是同时进行，所以要放在同一个花括号里</span><br><span class="line">        if (root.left != null) { // 左</span><br><span class="line">            traversal(root.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">        }</span><br><span class="line">        if (root.right != null) { // 右</span><br><span class="line">            traversal(root.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - 1);// 回溯</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法的代码："><a href="#其他方法的代码：" class="headerlink" title="其他方法的代码："></a>其他方法的代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;Object&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 节点和路径同时入栈</span></span><br><span class="line">        stack.push(root);</span><br><span class="line">        stack.push(root.val + <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) {</span><br><span class="line">            <span class="comment">// 节点和路径同时出栈</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> (String) stack.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> (TreeNode) stack.pop();</span><br><span class="line">            <span class="comment">// 若找到叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) {</span><br><span class="line">                result.add(path);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//右子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) {</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                stack.push(path + <span class="string">"-&gt;"</span> + node.right.val);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//左子节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) {</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">                stack.push(path + <span class="string">"-&gt;"</span> + node.left.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="左叶子之和：LK404"><a href="#左叶子之和：LK404" class="headerlink" title="左叶子之和：LK404"></a>左叶子之和：LK404</h2><h3 id="思路：运用层序遍历收集每一层符合左叶子条件的节点的值"><a href="#思路：运用层序遍历收集每一层符合左叶子条件的节点的值" class="headerlink" title="思路：运用层序遍历收集每一层符合左叶子条件的节点的值"></a>思路：运用层序遍历收集每一层符合左叶子条件的节点的值</h3><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class LK404 {</span><br><span class="line">    static class TreeNode {</span><br><span class="line">    TreeNode left;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    public TreeNode(TreeNode left, int val,TreeNode right) {</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.right = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public TreeNode() {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        LK404 lk404 = new LK404();</span><br><span class="line">        TreeNode d = new TreeNode(null,12,null);</span><br><span class="line">        TreeNode b = new TreeNode(d,10,null);</span><br><span class="line">        TreeNode  e = new TreeNode(null,10,null);</span><br><span class="line">        TreeNode c = new TreeNode(e,15,null);</span><br><span class="line">        TreeNode a = new TreeNode(b ,11,c);</span><br><span class="line">        int sum = lk404.sumOfLeftLeaves2(a);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    }</span><br><span class="line">    public int sumOfLeftLeaves2(TreeNode root) {</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        int leftValue = sumOfLeftLeaves(root.left);    // 左</span><br><span class="line">        int rightValue = sumOfLeftLeaves(root.right);  // 右</span><br><span class="line"></span><br><span class="line">        int midValue = 0;</span><br><span class="line">        if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) {</span><br><span class="line">            midValue = root.left.val;</span><br><span class="line">        }</span><br><span class="line">        int sum = midValue + leftValue + rightValue;  // 中</span><br><span class="line">        return sum;</span><br><span class="line">    }</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">        int result = sumOfLeftLeave(root);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public int sumOfLeftLeave(TreeNode root){</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">       // ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while (! queue.isEmpty()){</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            for (int i = 0; i &lt; size; i++) {</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    //result.add(node.left.val);</span><br><span class="line">                    if (node.left.left == null &amp;&amp; node.left.right == null){</span><br><span class="line">                        sum += node.left.val;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;平衡二叉树：LK110&quot;&gt;&lt;a href=&quot;#平衡二叉树：LK110&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树：LK110&quot;&gt;&lt;/a&gt;平衡二叉树：LK110&lt;/h2&gt;&lt;h3 id=&quot;思路：用层序遍历，求取根节点的左右子树的层数差-小于等于1</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="回溯算法" scheme="https://cyc199811.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>day012</title>
    <link href="https://cyc199811.github.io/2024/05/04/day15/"/>
    <id>https://cyc199811.github.io/2024/05/04/day15/</id>
    <published>2024-05-04T04:43:15.000Z</published>
    <updated>2024-05-13T01:38:31.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的统一迭代法："><a href="#二叉树的统一迭代法：" class="headerlink" title="二叉树的统一迭代法："></a>二叉树的统一迭代法：</h1><h2 id="思路：利用栈的先进后出规则，并添加-null-值进行遍历"><a href="#思路：利用栈的先进后出规则，并添加-null-值进行遍历" class="headerlink" title="思路：利用栈的先进后出规则，并添加 null 值进行遍历"></a>思路：利用栈的先进后出规则，并添加 null 值进行遍历</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Tree1 {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 前序遍历顺序：中-左-右，入栈顺序：右-左-中</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">            stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            //节点的入栈顺序和遍历的完全相反</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">                stack.push(node);</span><br><span class="line"></span><br><span class="line">                stack.push(null);// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();//将空节点弹出栈</span><br><span class="line">                node = stack.peek();//重新取出栈中元素</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);//收集结果</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 中序遍历顺序: 左-中-右 入栈顺序： 右-中-左</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">        stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(null);</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 后序遍历顺序 左-右-中 入栈顺序：中-右-左</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root != null){</span><br><span class="line">            stack.push(root);</span><br><span class="line">        }</span><br><span class="line">        while (!stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            if (node != null){</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(null);</span><br><span class="line">                if (node.right != null){</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                }</span><br><span class="line">                if (node.left != null){</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                }</span><br><span class="line">            }else {</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二叉树的层序遍历："><a href="#二叉树的层序遍历：" class="headerlink" title="二叉树的层序遍历："></a>二叉树的层序遍历：</h1><h2 id="思路：类似前序遍历，但要每层进行结果收集"><a href="#思路：类似前序遍历，但要每层进行结果收集" class="headerlink" title="思路：类似前序遍历，但要每层进行结果收集"></a>思路：类似前序遍历，但要每层进行结果收集</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class TreeLevelOrder {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br><span class="line">        //checkFun01(root,0);</span><br><span class="line">        checkFun02(root);</span><br><span class="line"></span><br><span class="line">        return resList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //DFS--递归方式</span><br><span class="line">    public void checkFun01(TreeNode node, Integer deep) {</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        deep++;</span><br><span class="line"></span><br><span class="line">        if (resList.size() &lt; deep) {</span><br><span class="line">            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span><br><span class="line">            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            resList.add(item);</span><br><span class="line">        }</span><br><span class="line">        resList.get(deep - 1).add(node.val);</span><br><span class="line"></span><br><span class="line">        checkFun01(node.left, deep);</span><br><span class="line">        checkFun01(node.right, deep);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //BFS--迭代方式--借助队列</span><br><span class="line">    public void checkFun02(TreeNode node) {</span><br><span class="line">        if (node == null) return;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        que.offer(node);</span><br><span class="line"></span><br><span class="line">        while (!que.isEmpty()) {</span><br><span class="line">            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            int len = que.size();</span><br><span class="line"></span><br><span class="line">            while (len &gt; 0) {</span><br><span class="line">                TreeNode tmpNode = que.poll();</span><br><span class="line">                itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">                if (tmpNode.left != null) que.offer(tmpNode.left);</span><br><span class="line">                if (tmpNode.right != null) que.offer(tmpNode.right);</span><br><span class="line">                len--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            resList.add(itemList);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的统一迭代法：&quot;&gt;&lt;a href=&quot;#二叉树的统一迭代法：&quot; class=&quot;headerlink&quot; title=&quot;二叉树的统一迭代法：&quot;&gt;&lt;/a&gt;二叉树的统一迭代法：&lt;/h1&gt;&lt;h2 id=&quot;思路：利用栈的先进后出规则，并添加-null-值进行遍历&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树的遍历" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>day013</title>
    <link href="https://cyc199811.github.io/2024/05/04/day18/"/>
    <id>https://cyc199811.github.io/2024/05/04/day18/</id>
    <published>2024-05-04T04:43:15.000Z</published>
    <updated>2024-05-13T01:38:19.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻转二叉树：LK226"><a href="#翻转二叉树：LK226" class="headerlink" title="翻转二叉树：LK226"></a>翻转二叉树：LK226</h2><h3 id="思路：交换左右孩子的值，利用递归函数一直向下递归就行！💪"><a href="#思路：交换左右孩子的值，利用递归函数一直向下递归就行！💪" class="headerlink" title="思路：交换左右孩子的值，利用递归函数一直向下递归就行！💪"></a>思路：交换左右孩子的值，利用递归函数一直向下递归就行！💪</h3><img src="https://code-thinking.cdn.bcebos.com/gifs/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.gif" alt="翻转二叉树" style="zoom: 200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class num226 {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public TreeNode invertTree(TreeNode root) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return null;</span><br><span class="line">        }</span><br><span class="line">        swap(root);</span><br><span class="line">        return root;</span><br><span class="line">    }</span><br><span class="line">    public void swap(TreeNode root){</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        swap(left);</span><br><span class="line">        swap(right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法的代码："><a href="#其他方法的代码：" class="headerlink" title="其他方法的代码："></a>其他方法的代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DFS递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前后序遍历都可以</span></span><br><span class="line"><span class="comment">     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        swapChildren(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapChildren</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) {<span class="keyword">return</span> <span class="literal">null</span>;}</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) deque.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) deque.offer(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="对称二叉树：LK101"><a href="#对称二叉树：LK101" class="headerlink" title="对称二叉树：LK101"></a>对称二叉树：LK101</h2><h3 id="思路：比较根节点的左右子树，比较左右子树的节点值是否相等"><a href="#思路：比较根节点的左右子树，比较左右子树的节点值是否相等" class="headerlink" title="思路：比较根节点的左右子树，比较左右子树的节点值是否相等"></a>思路：比较根节点的左右子树，比较左右子树的节点值是否相等</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203144624414.png" alt="101. 对称二叉树1"></p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">public class num101 {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    public boolean isSymmetric(TreeNode root) {</span><br><span class="line">        return compare(root.left, root.right);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private boolean compare(TreeNode left, TreeNode right) {</span><br><span class="line"></span><br><span class="line">        if (left == null &amp;&amp; right != null) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        if (left != null &amp;&amp; right == null) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (left == null &amp;&amp; right == null) {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">        if (left.val != right.val) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        // 比较外侧</span><br><span class="line">        boolean compareOutside = compare(left.left, right.right);</span><br><span class="line">        // 比较内侧</span><br><span class="line">        boolean compareInside = compare(left.right, right.left);</span><br><span class="line">        return compareOutside &amp;&amp; compareInside;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法代码："><a href="#其他方法代码：" class="headerlink" title="其他方法代码："></a>其他方法代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric3</span><span class="params">(TreeNode root)</span> {</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) {</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) {</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;翻转二叉树：LK226&quot;&gt;&lt;a href=&quot;#翻转二叉树：LK226&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树：LK226&quot;&gt;&lt;/a&gt;翻转二叉树：LK226&lt;/h2&gt;&lt;h3 id=&quot;思路：交换左右孩子的值，利用递归函数一直向下递归就行！💪</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="递归" scheme="https://cyc199811.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍</title>
    <link href="https://cyc199811.github.io/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <id>https://cyc199811.github.io/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</id>
    <published>2024-05-04T04:43:15.000Z</published>
    <updated>2024-05-13T01:44:34.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打家劫舍：LK198"><a href="#打家劫舍：LK198" class="headerlink" title="打家劫舍：LK198"></a>打家劫舍：LK198</h2><h3 id="思路：利用动规五部曲，确定dp-i-的含义是第i-个房间的最大值"><a href="#思路：利用动规五部曲，确定dp-i-的含义是第i-个房间的最大值" class="headerlink" title="思路：利用动规五部曲，确定dp[i]的含义是第i 个房间的最大值"></a>思路：利用动规五部曲，确定dp[i]的含义是第i 个房间的最大值</h3><h3 id="其中分为偷与不偷两种情况"><a href="#其中分为偷与不偷两种情况" class="headerlink" title="其中分为偷与不偷两种情况"></a>其中分为偷与不偷两种情况</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK198 {</span><br><span class="line">    public int rob(int[] nums) {</span><br><span class="line">    if (nums == null || nums.length == 0) return 0;</span><br><span class="line">  if (nums.length == 1) return nums[0];</span><br><span class="line">       //1.定义dp[]数组</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        //2.初始化数组</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class="line">        //3.确定遍历顺序</span><br><span class="line">        for (int i = 2; i &lt; nums.length; i++) {</span><br><span class="line">            //4.确定递推公式</span><br><span class="line">            //取和不取num[i]的最大值就是dp[i]</span><br><span class="line">            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i -1]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return dp[nums.length - 1];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //5.打印数组案例</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] nums = {2,7,9,3,1};</span><br><span class="line">        LK198 lk198 = new LK198();</span><br><span class="line">        int rob = lk198.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="其他方法的代码："><a href="#其他方法的代码：" class="headerlink" title="其他方法的代码："></a>其他方法的代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用滚动数组思想，优化空间</span></span><br><span class="line"><span class="comment">// 分析本题可以发现，所求结果仅依赖于前两种状态，此时可以使用滚动数组思想将空间复杂度降低为3个空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">//存放选择的结果</span></span><br><span class="line">        result[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++){</span><br><span class="line"></span><br><span class="line">            result[<span class="number">2</span>] = Math.max(result[<span class="number">0</span>]+nums[i],result[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            result[<span class="number">0</span>] = result[<span class="number">1</span>];</span><br><span class="line">            result[<span class="number">1</span>] = result[<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result[<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步对滚动数组的空间优化 dp数组只存与计算相关的两次数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> {</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)  {</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 初始化dp数组</span></span><br><span class="line">        <span class="comment">// 优化空间 dp数组只用2格空间 只记录与当前计算相关的前两个结果</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) {</span><br><span class="line">            res = Math.max((dp[<span class="number">0</span>] + nums[i]) , dp[<span class="number">1</span>] );</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = res;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打家劫舍2：LK213"><a href="#打家劫舍2：LK213" class="headerlink" title="打家劫舍2：LK213"></a>打家劫舍2：LK213</h2><h3 id="思路：将数组分为不包含首尾元素，包含首元素不包含尾元素以及包含尾元素不包含首元素3种状态！"><a href="#思路：将数组分为不包含首尾元素，包含首元素不包含尾元素以及包含尾元素不包含首元素3种状态！" class="headerlink" title="思路：将数组分为不包含首尾元素，包含首元素不包含尾元素以及包含尾元素不包含首元素3种状态！"></a>思路：将数组分为不包含首尾元素，包含首元素不包含尾元素以及包含尾元素不包含首元素3种状态！</h3><h3 id="但是第一种情况被后面的涵盖了"><a href="#但是第一种情况被后面的涵盖了" class="headerlink" title="但是第一种情况被后面的涵盖了"></a>但是第一种情况被后面的涵盖了</h3><img src="/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20240504095517024.png" alt="image-20240504095517024" style="zoom:200%;"><img src="/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20240504095612931.png" alt="image-20240504095612931" style="zoom:200%;"><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a><img src="/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20240504095706752.png" alt="image-20240504095706752" style="zoom:200%;">代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">public class LK213 {</span><br><span class="line">    public int rob(int[] nums) {</span><br><span class="line">        if (nums == null || nums.length == 0) return 0;</span><br><span class="line">        if (nums.length == 1) return nums[0];</span><br><span class="line">        //1.定义dp[]数组</span><br><span class="line">        int[][] dp = new int[2][nums.length];</span><br><span class="line">        //2.初始化数组</span><br><span class="line">        dp[0][0] = nums[0];//含有首元素不含尾元素</span><br><span class="line">        dp[1][0] = 0;//含有尾元素不含有首元素</span><br><span class="line">        dp[0][1] = nums[0];</span><br><span class="line">        dp[1][1] = nums[1];</span><br><span class="line">        //3.确定遍历顺序</span><br><span class="line">        for (int i = 2; i &lt; nums.length - 1; i++) {</span><br><span class="line">            //4.确定递推公式</span><br><span class="line">            //取和不取num[i]的最大值就是dp[i]</span><br><span class="line">           dp[0][i] = Math.max(dp[0][i -2] + nums[i], dp[0][i - 1]);</span><br><span class="line">        }</span><br><span class="line">        for (int i = 2; i &lt; nums.length; i++) {</span><br><span class="line">            //4.确定递推公式</span><br><span class="line">            //取和不取num[i]的最大值就是dp[i]</span><br><span class="line">            dp[1][i] = Math.max(dp[1][i -2] + nums[i], dp[1][i - 1]);</span><br><span class="line">        }</span><br><span class="line">        return Math.max(dp[0][nums.length - 2], dp[1][nums.length - 1]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //5.打印数组案例</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] nums = {2,3,1};</span><br><span class="line">        LK213 lk198 = new LK213();</span><br><span class="line">        int rob = lk198.rob(nums);</span><br><span class="line">        System.out.println(rob);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="打家劫舍3：LK337"><a href="#打家劫舍3：LK337" class="headerlink" title="打家劫舍3：LK337"></a>打家劫舍3：LK337</h2><h3 id="思路：利用后序遍历来求取"><a href="#思路：利用后序遍历来求取" class="headerlink" title="思路：利用后序遍历来求取"></a>思路：利用后序遍历来求取</h3><img src="/2024/05/04/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/image-20240504111738804.png" alt="image-20240504111738804" style="zoom:200%;"><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package org.example.动态规划;</span><br><span class="line"></span><br><span class="line">import org.example.二叉树.Tree;</span><br><span class="line">import org.example.二叉树.Tree1;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class LK337 {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    // 3.状态标记递归</span><br><span class="line">    // 执行用时：0 ms , 在所有 Java 提交中击败了 100% 的用户</span><br><span class="line">    // 不偷：Max(左孩子不偷，左孩子偷) + Max(右孩子不偷，右孩子偷)</span><br><span class="line">    // root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) +</span><br><span class="line">    // Math.max(rob(root.right)[0], rob(root.right)[1])</span><br><span class="line">    // 偷：左孩子不偷+ 右孩子不偷 + 当前节点偷</span><br><span class="line">    // root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;</span><br><span class="line">    public int rob(TreeNode root) {</span><br><span class="line">        int[] res = robAction1(root);</span><br><span class="line">        return Math.max(res[0], res[1]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int[] robAction1(TreeNode root) {</span><br><span class="line">        int res[] = new int[2];</span><br><span class="line">        if (root == null)</span><br><span class="line">            return res;</span><br><span class="line">//后序遍历 左-右-中</span><br><span class="line">        int[] left = robAction1(root.left);</span><br><span class="line">        int[] right = robAction1(root.right);</span><br><span class="line"></span><br><span class="line">        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);</span><br><span class="line">        res[1] = root.val + left[0] + right[0];</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;打家劫舍：LK198&quot;&gt;&lt;a href=&quot;#打家劫舍：LK198&quot; class=&quot;headerlink&quot; title=&quot;打家劫舍：LK198&quot;&gt;&lt;/a&gt;打家劫舍：LK198&lt;/h2&gt;&lt;h3 id=&quot;思路：利用动规五部曲，确定dp-i-的含义是第i-个房间的最大值&quot;</summary>
      
    
    
    
    <category term="动态规划" scheme="https://cyc199811.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="https://cyc199811.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>day011</title>
    <link href="https://cyc199811.github.io/2024/05/03/day14/"/>
    <id>https://cyc199811.github.io/2024/05/03/day14/</id>
    <published>2024-05-03T04:43:15.000Z</published>
    <updated>2024-05-13T01:39:08.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树的递归遍历："><a href="#二叉树的递归遍历：" class="headerlink" title="二叉树的递归遍历："></a>二叉树的递归遍历：</h2><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Tree {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //前序遍历</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public void preorder(TreeNode root, List&lt;Integer&gt; result){</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    }</span><br><span class="line">    //中序遍历</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    private void inorder(TreeNode root, List&lt;Integer&gt; result) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        inorder(root.left, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inorder(root.right, result);</span><br><span class="line">    }</span><br><span class="line">    //后序遍历</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        postorder(root, result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    private void postorder(TreeNode root, List&lt;Integer&gt; result) {</span><br><span class="line">        if (root == null){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        inorder(root.left, result);</span><br><span class="line">        inorder(root.right, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的迭代遍历："><a href="#二叉树的迭代遍历：" class="headerlink" title="二叉树的迭代遍历："></a>二叉树的迭代遍历：</h2><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package org.example.二叉树;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Tree {</span><br><span class="line"></span><br><span class="line">    public class TreeNode {</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode() {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val) {</span><br><span class="line">            this.val = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public TreeNode(int val, TreeNode left, TreeNode right) {</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.left = left;</span><br><span class="line">            this.right = right;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root){</span><br><span class="line">        ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while ( !stack.isEmpty()){</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.right != null){</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">            if (node.left != null){</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 中序遍历顺序: 左-中-右 入栈顺序： 左-右</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null){</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        while (cur != null || !stack.isEmpty()){</span><br><span class="line">            if (cur != null){</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            }else{</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    // 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null) {</span><br><span class="line">            return result;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while (!stack.isEmpty()) {</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            if (node.left != null) {</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            }</span><br><span class="line">            if (node.right != null) {</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二叉树的递归遍历：&quot;&gt;&lt;a href=&quot;#二叉树的递归遍历：&quot; class=&quot;headerlink&quot; title=&quot;二叉树的递归遍历：&quot;&gt;&lt;/a&gt;二叉树的递归遍历：&lt;/h2&gt;&lt;h3 id=&quot;代码：&quot;&gt;&lt;a href=&quot;#代码：&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="二叉树" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
    <category term="二叉树的遍历" scheme="https://cyc199811.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://cyc199811.github.io/2024/05/03/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://cyc199811.github.io/2024/05/03/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2024-05-03T04:43:15.000Z</published>
    <updated>2024-05-03T22:24:26.087Z</updated>
    
    <content type="html"><![CDATA[<p>##柱状图中最大的矩形：LK084</p><h3 id="思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，"><a href="#思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，" class="headerlink" title="思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，"></a>思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，</h3><p>   int mid = st.peek();<br>                    st.pop();<br>                    int left = st.peek();<br>                    int right = i;<br>                    int w = right - left - 1;<br>                    int h = heights[mid];<br>                    result = Math.max(result, w * h);</p><h3 id="分别找到左边界和右边界计算出宽度"><a href="#分别找到左边界和右边界计算出宽度" class="headerlink" title="分别找到左边界和右边界计算出宽度"></a>分别找到左边界和右边界计算出宽度</h3><h3 id="高则是对应下标的-heights-mid"><a href="#高则是对应下标的-heights-mid" class="headerlink" title="高则是对应下标的 heights[mid]"></a>高则是对应下标的 heights[mid]</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package org.example.单调栈;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class LK084 {</span><br><span class="line">    public int largestRectangleArea3(int[] heights) {</span><br><span class="line"></span><br><span class="line">        int[] newHeight = new int[heights.length + 2];</span><br><span class="line">        System.arraycopy(heights, 0, newHeight, 1, heights.length);</span><br><span class="line">        newHeight[heights.length+1] = 0;</span><br><span class="line">        newHeight[0] = 0;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(0);</span><br><span class="line"></span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 1; i &lt; newHeight.length; i++) {</span><br><span class="line">            while (newHeight[i] &lt; newHeight[stack.peek()]) {</span><br><span class="line">                int mid = stack.pop();</span><br><span class="line">                int w = i - stack.peek() - 1;</span><br><span class="line">                int h = newHeight[mid];</span><br><span class="line">                res = Math.max(res, w * h);</span><br><span class="line">            }</span><br><span class="line">            stack.push(i);</span><br><span class="line">        }</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line">    int largestRectangleArea2(int[] heights) {</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        // 数组扩容，在头和尾各加入一个元素</span><br><span class="line">        int [] newHeights = new int[heights.length + 2];</span><br><span class="line">        newHeights[0] = 0;</span><br><span class="line">        newHeights[newHeights.length - 1] = 0;</span><br><span class="line">        for (int index = 0; index &lt; heights.length; index++){</span><br><span class="line">            newHeights[index + 1] = heights[index];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        st.push(0);</span><br><span class="line">        int result = 0;</span><br><span class="line">        // 第一个元素已经入栈，从下标1开始</span><br><span class="line">        for (int i = 1; i &lt; heights.length; i++) {</span><br><span class="line">            // 注意heights[i] 是和heights[st.top()] 比较 ，st.top()是下标</span><br><span class="line">            if (heights[i] &gt; heights[st.peek()]) {</span><br><span class="line">                st.push(i);</span><br><span class="line">            } else if (heights[i] == heights[st.peek()]) {</span><br><span class="line">                st.pop(); // 这个可以加，可以不加，效果一样，思路不同</span><br><span class="line">                st.push(i);</span><br><span class="line">            } else {</span><br><span class="line">                while (heights[i] &lt; heights[st.peek()]) { // 注意是while</span><br><span class="line">                    int mid = st.peek();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    int left = st.peek();</span><br><span class="line">                    int right = i;</span><br><span class="line">                    int w = right - left - 1;</span><br><span class="line">                    int h = heights[mid];</span><br><span class="line">                    result = Math.max(result, w * h);</span><br><span class="line">                }</span><br><span class="line">                st.push(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    public int largestRectangleArea(int[] heights) {</span><br><span class="line">        int length = heights.length;</span><br><span class="line">        int[] minLeftIndex = new int [length];</span><br><span class="line">        int[] minRightIndex = new int [length];</span><br><span class="line">        // 记录左边第一个小于该柱子的下标</span><br><span class="line">        minLeftIndex[0] = -1 ;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) {</span><br><span class="line">            int t = i - 1;</span><br><span class="line">            // 这里不是用if，而是不断向右寻找的过程</span><br><span class="line">            while (t &gt;= 0 &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];</span><br><span class="line">            minLeftIndex[i] = t;</span><br><span class="line">        }</span><br><span class="line">        // 记录每个柱子右边第一个小于该柱子的下标</span><br><span class="line">        minRightIndex[length - 1] = length;</span><br><span class="line">        for (int i = length - 2; i &gt;= 0; i--) {</span><br><span class="line">            int t = i + 1;</span><br><span class="line">            while(t &lt; length &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];</span><br><span class="line">            minRightIndex[i] = t;</span><br><span class="line">        }</span><br><span class="line">        // 求和</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int i = 0; i &lt; length; i++) {</span><br><span class="line">            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);</span><br><span class="line">            result = Math.max(sum, result);</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] heights = {2,4};</span><br><span class="line">        LK084 lk084 = new LK084();</span><br><span class="line">        int size = lk084.largestRectangleArea(heights);</span><br><span class="line">        System.out.println(size);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##柱状图中最大的矩形：LK084&lt;/p&gt;
&lt;h3 id=&quot;思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，&quot;&gt;&lt;a href=&quot;#思路：利用单调栈来保持栈内元素单调递增，遇到小于栈口元素时就进行面积的计算，&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="单调栈" scheme="https://cyc199811.github.io/categories/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>day09</title>
    <link href="https://cyc199811.github.io/2024/05/02/day13/"/>
    <id>https://cyc199811.github.io/2024/05/02/day13/</id>
    <published>2024-05-02T04:43:15.000Z</published>
    <updated>2024-05-13T01:39:24.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口：LK239"><a href="#滑动窗口：LK239" class="headerlink" title="滑动窗口：LK239"></a>滑动窗口：LK239</h2><h3 id="思路：单调栈，保持队列内的元素单调增！获取队列口元素！"><a href="#思路：单调栈，保持队列内的元素单调增！获取队列口元素！" class="headerlink" title="思路：单调栈，保持队列内的元素单调增！获取队列口元素！"></a>思路：单调栈，保持队列内的元素单调增！获取队列口元素！</h3><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayDeque;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num239 {</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) {</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int[] res = new int[n - k + 1];</span><br><span class="line">        int idx = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; i++) {</span><br><span class="line">            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点</span><br><span class="line">            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){</span><br><span class="line">                deque.poll();</span><br><span class="line">            }</span><br><span class="line">            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出</span><br><span class="line">            while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) {</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            deque.offer(i);</span><br><span class="line"></span><br><span class="line">            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了</span><br><span class="line">            if(i &gt;= k - 1){</span><br><span class="line">                res[idx++] = nums[deque.peek()];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        int[] nums = {1, -1};</span><br><span class="line">        num239 num239 = new num239();</span><br><span class="line">        int[] res = num239.maxSlidingWindow(nums, 1);</span><br><span class="line">        for (int re : res) {</span><br><span class="line">            System.out.println(re);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="前K个高频元素：LK347"><a href="#前K个高频元素：LK347" class="headerlink" title="前K个高频元素：LK347"></a>前K个高频元素：LK347</h2><h3 id="思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！"><a href="#思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！" class="headerlink" title="思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！"></a>思路：运用小顶堆来存储前k个高频元素！优先级队列就是基于堆来实现的！</h3><h3 id="小顶堆就是一个二叉树"><a href="#小顶堆就是一个二叉树" class="headerlink" title="小顶堆就是一个二叉树"></a>小顶堆就是一个二叉树</h3><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int[] topKFrequent2(int[] nums, int k) {</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数</span><br><span class="line">    for (int num : nums) {</span><br><span class="line">        map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">    }</span><br><span class="line">    //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span><br><span class="line">    //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span><br><span class="line">    PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);</span><br><span class="line">    for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { //小顶堆只需要维持k个元素有序</span><br><span class="line">        if (pq.size() &lt; k) { //小顶堆元素个数小于k个时直接加</span><br><span class="line">            pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br><span class="line">        } else {</span><br><span class="line">            if (entry.getValue() &gt; pq.peek()[1]) { //当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span><br><span class="line">                pq.poll(); //弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span><br><span class="line">                pq.add(new int[]{entry.getKey(), entry.getValue()});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    int[] ans = new int[k];</span><br><span class="line">    for (int i = k - 1; i &gt;= 0; i--) { //依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span><br><span class="line">        ans[i] = pq.poll()[0];</span><br><span class="line">    }</span><br><span class="line">    return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;滑动窗口：LK239&quot;&gt;&lt;a href=&quot;#滑动窗口：LK239&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口：LK239&quot;&gt;&lt;/a&gt;滑动窗口：LK239&lt;/h2&gt;&lt;h3 id=&quot;思路：单调栈，保持队列内的元素单调增！获取队列口元素！&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    <category term="优先级队列" scheme="https://cyc199811.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    
    <category term="小顶堆" scheme="https://cyc199811.github.io/tags/%E5%B0%8F%E9%A1%B6%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>day08</title>
    <link href="https://cyc199811.github.io/2024/04/27/day11/"/>
    <id>https://cyc199811.github.io/2024/04/27/day11/</id>
    <published>2024-04-27T04:43:15.000Z</published>
    <updated>2024-05-13T01:39:32.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效的括号：LK020😂"><a href="#有效的括号：LK020😂" class="headerlink" title="有效的括号：LK020😂"></a>有效的括号：LK020😂</h2><h3 id="思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！"><a href="#思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！" class="headerlink" title="思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！"></a>思路：用栈来存储对应遍历的括号的右括号；当遇到右括号就弹栈；如果都匹配最后栈会为空，反之则不会为空！！！</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num020 {</span><br><span class="line">    public boolean isValid(String s) {</span><br><span class="line">        //括号只能成对</span><br><span class="line">        if (s.length() % 2 != 0 || s.length() == 0) {</span><br><span class="line">            return false;</span><br><span class="line">        }</span><br><span class="line">        Stack&lt;Character&gt; stackChars = new Stack&lt;&gt;();</span><br><span class="line">        char ch;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            if (ch == '(') {</span><br><span class="line">                stackChars.push(')');</span><br><span class="line">            } else if (ch == '[') {</span><br><span class="line">                stackChars.push(']');</span><br><span class="line">            } else if (ch == '{') {</span><br><span class="line">                stackChars.push('}');</span><br><span class="line">            } else if (stackChars.isEmpty() || stackChars.peek() != ch) {</span><br><span class="line">                return false;</span><br><span class="line">            } else {</span><br><span class="line">                stackChars.pop();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return stackChars.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        String s1 = "()[]{}";</span><br><span class="line">       // String s2 = "()}";</span><br><span class="line">        //String s3 = "([]}";</span><br><span class="line">        num020 num020 = new num020();</span><br><span class="line">        boolean s11 = num020.isValid(s1);</span><br><span class="line">        System.out.println(s11);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="删除字符串中的所有相邻重复项-LK1047"><a href="#删除字符串中的所有相邻重复项-LK1047" class="headerlink" title="删除字符串中的所有相邻重复项: LK1047"></a>删除字符串中的所有相邻重复项: LK1047</h2><h3 id="思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！"><a href="#思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！" class="headerlink" title="思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！"></a>思路：将遍历的字符和栈顶的进行对比，相等就弹栈，不相等就放入栈，最后进行一个结果的搜集！</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class num1047 {</span><br><span class="line">    public String removeDuplicates(String s) {</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) {</span><br><span class="line">            if (stack.isEmpty()){</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            }else {</span><br><span class="line">                if (s.charAt(i) != stack.peek()){</span><br><span class="line">                    stack.push(s.charAt(i));</span><br><span class="line">                }else {</span><br><span class="line">                    stack.pop();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        int lenth = stack.size();</span><br><span class="line">        char[] sresult = new char[lenth];</span><br><span class="line">        while (! stack.isEmpty()){</span><br><span class="line">            sresult[lenth - 1] = stack.pop();</span><br><span class="line">            lenth --;</span><br><span class="line">        }</span><br><span class="line">        String result = new String(sresult);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="逆波兰表达式：LK150"><a href="#逆波兰表达式：LK150" class="headerlink" title="逆波兰表达式：LK150"></a>逆波兰表达式：LK150</h2><h3 id="思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！"><a href="#思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！" class="headerlink" title="思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！"></a>思路：将运算符与数字区分开，不是运算符放入栈，是运算符就弹出栈顶的前两个数进行运算后的结果再放入栈，最后返回最终的栈顶元素就是结果！！</h3><h3 id="注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：-a-b-a先入栈后出栈-，所以是：-a-b"><a href="#注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：-a-b-a先入栈后出栈-，所以是：-a-b" class="headerlink" title="注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：[a, b, /] a先入栈后出栈 ，所以是：  a / b"></a>注意事项：在进行减法和除法运算的时候，必须后面的减去前面的或者除以前面的！例如：[a, b, /] a先入栈后出栈 ，所以是：  a / b</h3><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈与队列;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LK150 {</span><br><span class="line">    public int evalRPN(String[] tokens) {</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        for (String t : tokens) {</span><br><span class="line">        switch (t){</span><br><span class="line">            case "+" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b+a);</span><br><span class="line">            }</span><br><span class="line">            case "-" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b-a);</span><br><span class="line">            }</span><br><span class="line">            case "*" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b*a);</span><br><span class="line">            }</span><br><span class="line">            case "/" -&gt;{</span><br><span class="line">                Integer a = stack.pop();</span><br><span class="line">                Integer b = stack.pop();</span><br><span class="line">                stack.push(b/a);</span><br><span class="line">            }</span><br><span class="line">            default -&gt; {        //数字</span><br><span class="line">                stack.push(Integer.parseInt(t));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        return stack.pop();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效的括号：LK020😂&quot;&gt;&lt;a href=&quot;#有效的括号：LK020😂&quot; class=&quot;headerlink&quot; title=&quot;有效的括号：LK020😂&quot;&gt;&lt;/a&gt;有效的括号：LK020😂&lt;/h2&gt;&lt;h3 id=&quot;思路：用栈来存储对应遍历的括号的右括号；当</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="https://cyc199811.github.io/2024/04/26/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://cyc199811.github.io/2024/04/26/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2024-04-26T04:43:15.000Z</published>
    <updated>2024-05-13T01:44:30.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用栈实现队列："><a href="#用栈实现队列：" class="headerlink" title="用栈实现队列："></a>用栈实现队列：</h2><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="232.用栈实现队列版本2" style="zoom:200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package org.example.栈;</span><br><span class="line"></span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class MyQueue {</span><br><span class="line">    Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    public MyQueue() {</span><br><span class="line">        Stack&lt;Integer&gt; inStack = new Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; outStack = new Stack&lt;Integer&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void push(int x) {</span><br><span class="line">        while (!outStack.isEmpty()){</span><br><span class="line">            inStack.push(outStack.pop());</span><br><span class="line">        }</span><br><span class="line">        outStack.push(x);</span><br><span class="line">        while (!inStack.isEmpty()){</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int pop()  {</span><br><span class="line">       int pop =  outStack.pop();</span><br><span class="line">        return pop;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int peek() {</span><br><span class="line">        int peek =  inStack.peek();</span><br><span class="line">        return peek;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean empty() {</span><br><span class="line">        return inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用栈实现队列：&quot;&gt;&lt;a href=&quot;#用栈实现队列：&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列：&quot;&gt;&lt;/a&gt;用栈实现队列：&lt;/h2&gt;&lt;img src=&quot;https://code-thinking.cdn.bcebos.com/gifs/2</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>用队列实现栈</title>
    <link href="https://cyc199811.github.io/2024/04/26/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://cyc199811.github.io/2024/04/26/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</id>
    <published>2024-04-26T04:43:15.000Z</published>
    <updated>2024-05-13T01:44:19.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用队列实现栈："><a href="#用队列实现栈：" class="headerlink" title="用队列实现栈："></a>用队列实现栈：</h2><img src="https://code-thinking.cdn.bcebos.com/gifs/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif" alt="225.用队列实现栈" style="zoom: 200%;"><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    <span class="comment">//q1作为主要的队列，其元素排列顺序和出栈顺序相同</span></span><br><span class="line">    Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//q2仅作为临时放置</span></span><br><span class="line">    Queue&lt;Integer&gt; q2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//在加入元素时先将q1中的元素依次出栈压入q2，然后将新加入的元素压入q1，再将q2中的元素依次出栈压入q1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            q2.add(q1.poll());</span><br><span class="line">        }</span><br><span class="line">        q1.add(x);</span><br><span class="line">        <span class="keyword">while</span> (q2.size() &gt; <span class="number">0</span>) {</span><br><span class="line">            q1.add(q2.poll());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">//移动除了 A 的其它数</span></span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>)</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> {</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        queue.add(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> {</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        queue.add(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用队列实现栈：&quot;&gt;&lt;a href=&quot;#用队列实现栈：&quot; class=&quot;headerlink&quot; title=&quot;用队列实现栈：&quot;&gt;&lt;/a&gt;用队列实现栈：&lt;/h2&gt;&lt;img src=&quot;https://code-thinking.cdn.bcebos.com/gifs/2</summary>
      
    
    
    
    <category term="代码随想录每日刷题" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/"/>
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E6%AF%8F%E6%97%A5%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    
    <category term="栈与队列" scheme="https://cyc199811.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
